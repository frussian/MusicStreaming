// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_messages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_messages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_messages_2eproto;
class Album;
struct AlbumDefaultTypeInternal;
extern AlbumDefaultTypeInternal _Album_default_instance_;
class Answer;
struct AnswerDefaultTypeInternal;
extern AnswerDefaultTypeInternal _Answer_default_instance_;
class Band;
struct BandDefaultTypeInternal;
extern BandDefaultTypeInternal _Band_default_instance_;
class Concert;
struct ConcertDefaultTypeInternal;
extern ConcertDefaultTypeInternal _Concert_default_instance_;
class Membership;
struct MembershipDefaultTypeInternal;
extern MembershipDefaultTypeInternal _Membership_default_instance_;
class Musician;
struct MusicianDefaultTypeInternal;
extern MusicianDefaultTypeInternal _Musician_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class SimpleAns;
struct SimpleAnsDefaultTypeInternal;
extern SimpleAnsDefaultTypeInternal _SimpleAns_default_instance_;
class SimpleReq;
struct SimpleReqDefaultTypeInternal;
extern SimpleReqDefaultTypeInternal _SimpleReq_default_instance_;
class Song;
struct SongDefaultTypeInternal;
extern SongDefaultTypeInternal _Song_default_instance_;
class StreamAns;
struct StreamAnsDefaultTypeInternal;
extern StreamAnsDefaultTypeInternal _StreamAns_default_instance_;
class StreamReq;
struct StreamReqDefaultTypeInternal;
extern StreamReqDefaultTypeInternal _StreamReq_default_instance_;
class TableAns;
struct TableAnsDefaultTypeInternal;
extern TableAnsDefaultTypeInternal _TableAns_default_instance_;
class TableReq;
struct TableReqDefaultTypeInternal;
extern TableReqDefaultTypeInternal _TableReq_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Album* Arena::CreateMaybeMessage<::Album>(Arena*);
template<> ::Answer* Arena::CreateMaybeMessage<::Answer>(Arena*);
template<> ::Band* Arena::CreateMaybeMessage<::Band>(Arena*);
template<> ::Concert* Arena::CreateMaybeMessage<::Concert>(Arena*);
template<> ::Membership* Arena::CreateMaybeMessage<::Membership>(Arena*);
template<> ::Musician* Arena::CreateMaybeMessage<::Musician>(Arena*);
template<> ::Request* Arena::CreateMaybeMessage<::Request>(Arena*);
template<> ::SimpleAns* Arena::CreateMaybeMessage<::SimpleAns>(Arena*);
template<> ::SimpleReq* Arena::CreateMaybeMessage<::SimpleReq>(Arena*);
template<> ::Song* Arena::CreateMaybeMessage<::Song>(Arena*);
template<> ::StreamAns* Arena::CreateMaybeMessage<::StreamAns>(Arena*);
template<> ::StreamReq* Arena::CreateMaybeMessage<::StreamReq>(Arena*);
template<> ::TableAns* Arena::CreateMaybeMessage<::TableAns>(Arena*);
template<> ::TableReq* Arena::CreateMaybeMessage<::TableReq>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum EntityType : int {
  BAND = 0,
  ALBUM = 1,
  SONG = 2,
  CONCERT = 3,
  MUSICIAN = 4,
  MEMBERSHIP = 5,
  EntityType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EntityType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EntityType_IsValid(int value);
constexpr EntityType EntityType_MIN = BAND;
constexpr EntityType EntityType_MAX = MEMBERSHIP;
constexpr int EntityType_ARRAYSIZE = EntityType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EntityType_descriptor();
template<typename T>
inline const std::string& EntityType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EntityType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EntityType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EntityType_descriptor(), enum_t_value);
}
inline bool EntityType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EntityType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EntityType>(
    EntityType_descriptor(), name, value);
}
enum Genre : int {
  ROCK = 0,
  ALTERNATIVE = 1,
  INDIE = 2,
  BLUES = 3,
  METAL = 4,
  Genre_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Genre_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Genre_IsValid(int value);
constexpr Genre Genre_MIN = ROCK;
constexpr Genre Genre_MAX = METAL;
constexpr int Genre_ARRAYSIZE = Genre_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Genre_descriptor();
template<typename T>
inline const std::string& Genre_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Genre>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Genre_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Genre_descriptor(), enum_t_value);
}
inline bool Genre_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Genre* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Genre>(
    Genre_descriptor(), name, value);
}
// ===================================================================

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit PROTOBUF_CONSTEXPR Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kTableReq = 4,
    kSimpleReq = 5,
    kStreamReq = 6,
    MSG_NOT_SET = 0,
  };

  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Request& from) {
    Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
    kCancelFieldNumber = 3,
    kTableReqFieldNumber = 4,
    kSimpleReqFieldNumber = 5,
    kStreamReqFieldNumber = 6,
  };
  // uint64 reqId = 1;
  void clear_reqid();
  uint64_t reqid() const;
  void set_reqid(uint64_t value);
  private:
  uint64_t _internal_reqid() const;
  void _internal_set_reqid(uint64_t value);
  public:

  // bool cancel = 3;
  void clear_cancel();
  bool cancel() const;
  void set_cancel(bool value);
  private:
  bool _internal_cancel() const;
  void _internal_set_cancel(bool value);
  public:

  // .TableReq tableReq = 4;
  bool has_tablereq() const;
  private:
  bool _internal_has_tablereq() const;
  public:
  void clear_tablereq();
  const ::TableReq& tablereq() const;
  PROTOBUF_NODISCARD ::TableReq* release_tablereq();
  ::TableReq* mutable_tablereq();
  void set_allocated_tablereq(::TableReq* tablereq);
  private:
  const ::TableReq& _internal_tablereq() const;
  ::TableReq* _internal_mutable_tablereq();
  public:
  void unsafe_arena_set_allocated_tablereq(
      ::TableReq* tablereq);
  ::TableReq* unsafe_arena_release_tablereq();

  // .SimpleReq simpleReq = 5;
  bool has_simplereq() const;
  private:
  bool _internal_has_simplereq() const;
  public:
  void clear_simplereq();
  const ::SimpleReq& simplereq() const;
  PROTOBUF_NODISCARD ::SimpleReq* release_simplereq();
  ::SimpleReq* mutable_simplereq();
  void set_allocated_simplereq(::SimpleReq* simplereq);
  private:
  const ::SimpleReq& _internal_simplereq() const;
  ::SimpleReq* _internal_mutable_simplereq();
  public:
  void unsafe_arena_set_allocated_simplereq(
      ::SimpleReq* simplereq);
  ::SimpleReq* unsafe_arena_release_simplereq();

  // .StreamReq streamReq = 6;
  bool has_streamreq() const;
  private:
  bool _internal_has_streamreq() const;
  public:
  void clear_streamreq();
  const ::StreamReq& streamreq() const;
  PROTOBUF_NODISCARD ::StreamReq* release_streamreq();
  ::StreamReq* mutable_streamreq();
  void set_allocated_streamreq(::StreamReq* streamreq);
  private:
  const ::StreamReq& _internal_streamreq() const;
  ::StreamReq* _internal_mutable_streamreq();
  public:
  void unsafe_arena_set_allocated_streamreq(
      ::StreamReq* streamreq);
  ::StreamReq* unsafe_arena_release_streamreq();

  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:Request)
 private:
  class _Internal;
  void set_has_tablereq();
  void set_has_simplereq();
  void set_has_streamreq();

  inline bool has_msg() const;
  inline void clear_has_msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t reqid_;
    bool cancel_;
    union MsgUnion {
      constexpr MsgUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::TableReq* tablereq_;
      ::SimpleReq* simplereq_;
      ::StreamReq* streamreq_;
    } msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Answer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Answer) */ {
 public:
  inline Answer() : Answer(nullptr) {}
  ~Answer() override;
  explicit PROTOBUF_CONSTEXPR Answer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Answer(const Answer& from);
  Answer(Answer&& from) noexcept
    : Answer() {
    *this = ::std::move(from);
  }

  inline Answer& operator=(const Answer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Answer& operator=(Answer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Answer& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kTableAns = 3,
    kSimpleAns = 4,
    kStreamAns = 5,
    MSG_NOT_SET = 0,
  };

  static inline const Answer* internal_default_instance() {
    return reinterpret_cast<const Answer*>(
               &_Answer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Answer& a, Answer& b) {
    a.Swap(&b);
  }
  inline void Swap(Answer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Answer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Answer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Answer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Answer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Answer& from) {
    Answer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Answer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Answer";
  }
  protected:
  explicit Answer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
    kCancelFieldNumber = 2,
    kTableAnsFieldNumber = 3,
    kSimpleAnsFieldNumber = 4,
    kStreamAnsFieldNumber = 5,
  };
  // uint64 reqId = 1;
  void clear_reqid();
  uint64_t reqid() const;
  void set_reqid(uint64_t value);
  private:
  uint64_t _internal_reqid() const;
  void _internal_set_reqid(uint64_t value);
  public:

  // bool cancel = 2;
  void clear_cancel();
  bool cancel() const;
  void set_cancel(bool value);
  private:
  bool _internal_cancel() const;
  void _internal_set_cancel(bool value);
  public:

  // .TableAns tableAns = 3;
  bool has_tableans() const;
  private:
  bool _internal_has_tableans() const;
  public:
  void clear_tableans();
  const ::TableAns& tableans() const;
  PROTOBUF_NODISCARD ::TableAns* release_tableans();
  ::TableAns* mutable_tableans();
  void set_allocated_tableans(::TableAns* tableans);
  private:
  const ::TableAns& _internal_tableans() const;
  ::TableAns* _internal_mutable_tableans();
  public:
  void unsafe_arena_set_allocated_tableans(
      ::TableAns* tableans);
  ::TableAns* unsafe_arena_release_tableans();

  // .SimpleAns simpleAns = 4;
  bool has_simpleans() const;
  private:
  bool _internal_has_simpleans() const;
  public:
  void clear_simpleans();
  const ::SimpleAns& simpleans() const;
  PROTOBUF_NODISCARD ::SimpleAns* release_simpleans();
  ::SimpleAns* mutable_simpleans();
  void set_allocated_simpleans(::SimpleAns* simpleans);
  private:
  const ::SimpleAns& _internal_simpleans() const;
  ::SimpleAns* _internal_mutable_simpleans();
  public:
  void unsafe_arena_set_allocated_simpleans(
      ::SimpleAns* simpleans);
  ::SimpleAns* unsafe_arena_release_simpleans();

  // .StreamAns streamAns = 5;
  bool has_streamans() const;
  private:
  bool _internal_has_streamans() const;
  public:
  void clear_streamans();
  const ::StreamAns& streamans() const;
  PROTOBUF_NODISCARD ::StreamAns* release_streamans();
  ::StreamAns* mutable_streamans();
  void set_allocated_streamans(::StreamAns* streamans);
  private:
  const ::StreamAns& _internal_streamans() const;
  ::StreamAns* _internal_mutable_streamans();
  public:
  void unsafe_arena_set_allocated_streamans(
      ::StreamAns* streamans);
  ::StreamAns* unsafe_arena_release_streamans();

  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:Answer)
 private:
  class _Internal;
  void set_has_tableans();
  void set_has_simpleans();
  void set_has_streamans();

  inline bool has_msg() const;
  inline void clear_has_msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t reqid_;
    bool cancel_;
    union MsgUnion {
      constexpr MsgUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::TableAns* tableans_;
      ::SimpleAns* simpleans_;
      ::StreamAns* streamans_;
    } msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class TableReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TableReq) */ {
 public:
  inline TableReq() : TableReq(nullptr) {}
  ~TableReq() override;
  explicit PROTOBUF_CONSTEXPR TableReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableReq(const TableReq& from);
  TableReq(TableReq&& from) noexcept
    : TableReq() {
    *this = ::std::move(from);
  }

  inline TableReq& operator=(const TableReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableReq& operator=(TableReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableReq* internal_default_instance() {
    return reinterpret_cast<const TableReq*>(
               &_TableReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TableReq& a, TableReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TableReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableReq& from) {
    TableReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TableReq";
  }
  protected:
  explicit TableReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 3,
    kFirstFieldNumber = 1,
    kLastFieldNumber = 2,
    kTypeFieldNumber = 4,
  };
  // string filter = 3;
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // uint32 first = 1;
  void clear_first();
  uint32_t first() const;
  void set_first(uint32_t value);
  private:
  uint32_t _internal_first() const;
  void _internal_set_first(uint32_t value);
  public:

  // uint32 last = 2;
  void clear_last();
  uint32_t last() const;
  void set_last(uint32_t value);
  private:
  uint32_t _internal_last() const;
  void _internal_set_last(uint32_t value);
  public:

  // .EntityType type = 4;
  void clear_type();
  ::EntityType type() const;
  void set_type(::EntityType value);
  private:
  ::EntityType _internal_type() const;
  void _internal_set_type(::EntityType value);
  public:

  // @@protoc_insertion_point(class_scope:TableReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    uint32_t first_;
    uint32_t last_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SimpleReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SimpleReq) */ {
 public:
  inline SimpleReq() : SimpleReq(nullptr) {}
  ~SimpleReq() override;
  explicit PROTOBUF_CONSTEXPR SimpleReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimpleReq(const SimpleReq& from);
  SimpleReq(SimpleReq&& from) noexcept
    : SimpleReq() {
    *this = ::std::move(from);
  }

  inline SimpleReq& operator=(const SimpleReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimpleReq& operator=(SimpleReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimpleReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimpleReq* internal_default_instance() {
    return reinterpret_cast<const SimpleReq*>(
               &_SimpleReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SimpleReq& a, SimpleReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SimpleReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimpleReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimpleReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SimpleReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SimpleReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SimpleReq& from) {
    SimpleReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimpleReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SimpleReq";
  }
  protected:
  explicit SimpleReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqStringFieldNumber = 1,
    kTypeFieldNumber = 4,
  };
  // string reqString = 1;
  void clear_reqstring();
  const std::string& reqstring() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reqstring(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reqstring();
  PROTOBUF_NODISCARD std::string* release_reqstring();
  void set_allocated_reqstring(std::string* reqstring);
  private:
  const std::string& _internal_reqstring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reqstring(const std::string& value);
  std::string* _internal_mutable_reqstring();
  public:

  // .EntityType type = 4;
  void clear_type();
  ::EntityType type() const;
  void set_type(::EntityType value);
  private:
  ::EntityType _internal_type() const;
  void _internal_set_type(::EntityType value);
  public:

  // @@protoc_insertion_point(class_scope:SimpleReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reqstring_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class StreamReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StreamReq) */ {
 public:
  inline StreamReq() : StreamReq(nullptr) {}
  ~StreamReq() override;
  explicit PROTOBUF_CONSTEXPR StreamReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamReq(const StreamReq& from);
  StreamReq(StreamReq&& from) noexcept
    : StreamReq() {
    *this = ::std::move(from);
  }

  inline StreamReq& operator=(const StreamReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamReq& operator=(StreamReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamReq* internal_default_instance() {
    return reinterpret_cast<const StreamReq*>(
               &_StreamReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StreamReq& a, StreamReq& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamReq& from) {
    StreamReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StreamReq";
  }
  protected:
  explicit StreamReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjIdFieldNumber = 1,
    kSuggestedSizeFieldNumber = 2,
  };
  // int64 objId = 1;
  void clear_objid();
  int64_t objid() const;
  void set_objid(int64_t value);
  private:
  int64_t _internal_objid() const;
  void _internal_set_objid(int64_t value);
  public:

  // int32 suggestedSize = 2;
  void clear_suggestedsize();
  int32_t suggestedsize() const;
  void set_suggestedsize(int32_t value);
  private:
  int32_t _internal_suggestedsize() const;
  void _internal_set_suggestedsize(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StreamReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t objid_;
    int32_t suggestedsize_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class TableAns final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TableAns) */ {
 public:
  inline TableAns() : TableAns(nullptr) {}
  ~TableAns() override;
  explicit PROTOBUF_CONSTEXPR TableAns(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableAns(const TableAns& from);
  TableAns(TableAns&& from) noexcept
    : TableAns() {
    *this = ::std::move(from);
  }

  inline TableAns& operator=(const TableAns& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableAns& operator=(TableAns&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableAns& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableAns* internal_default_instance() {
    return reinterpret_cast<const TableAns*>(
               &_TableAns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TableAns& a, TableAns& b) {
    a.Swap(&b);
  }
  inline void Swap(TableAns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableAns* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableAns* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableAns>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableAns& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableAns& from) {
    TableAns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableAns* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TableAns";
  }
  protected:
  explicit TableAns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBandsFieldNumber = 1,
    kAlbumsFieldNumber = 2,
    kConcertsFieldNumber = 3,
    kSongsFieldNumber = 4,
    kTypeFieldNumber = 5,
  };
  // repeated .Band bands = 1;
  int bands_size() const;
  private:
  int _internal_bands_size() const;
  public:
  void clear_bands();
  ::Band* mutable_bands(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Band >*
      mutable_bands();
  private:
  const ::Band& _internal_bands(int index) const;
  ::Band* _internal_add_bands();
  public:
  const ::Band& bands(int index) const;
  ::Band* add_bands();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Band >&
      bands() const;

  // repeated .Album albums = 2;
  int albums_size() const;
  private:
  int _internal_albums_size() const;
  public:
  void clear_albums();
  ::Album* mutable_albums(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Album >*
      mutable_albums();
  private:
  const ::Album& _internal_albums(int index) const;
  ::Album* _internal_add_albums();
  public:
  const ::Album& albums(int index) const;
  ::Album* add_albums();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Album >&
      albums() const;

  // repeated .Concert concerts = 3;
  int concerts_size() const;
  private:
  int _internal_concerts_size() const;
  public:
  void clear_concerts();
  ::Concert* mutable_concerts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Concert >*
      mutable_concerts();
  private:
  const ::Concert& _internal_concerts(int index) const;
  ::Concert* _internal_add_concerts();
  public:
  const ::Concert& concerts(int index) const;
  ::Concert* add_concerts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Concert >&
      concerts() const;

  // repeated .Song songs = 4;
  int songs_size() const;
  private:
  int _internal_songs_size() const;
  public:
  void clear_songs();
  ::Song* mutable_songs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Song >*
      mutable_songs();
  private:
  const ::Song& _internal_songs(int index) const;
  ::Song* _internal_add_songs();
  public:
  const ::Song& songs(int index) const;
  ::Song* add_songs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Song >&
      songs() const;

  // .EntityType type = 5;
  void clear_type();
  ::EntityType type() const;
  void set_type(::EntityType value);
  private:
  ::EntityType _internal_type() const;
  void _internal_set_type(::EntityType value);
  public:

  // @@protoc_insertion_point(class_scope:TableAns)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Band > bands_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Album > albums_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Concert > concerts_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Song > songs_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SimpleAns final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SimpleAns) */ {
 public:
  inline SimpleAns() : SimpleAns(nullptr) {}
  ~SimpleAns() override;
  explicit PROTOBUF_CONSTEXPR SimpleAns(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimpleAns(const SimpleAns& from);
  SimpleAns(SimpleAns&& from) noexcept
    : SimpleAns() {
    *this = ::std::move(from);
  }

  inline SimpleAns& operator=(const SimpleAns& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimpleAns& operator=(SimpleAns&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimpleAns& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kBand = 1,
    kAlbum = 2,
    kSong = 3,
    kConcert = 4,
    kMusician = 5,
    kMembership = 6,
    MSG_NOT_SET = 0,
  };

  static inline const SimpleAns* internal_default_instance() {
    return reinterpret_cast<const SimpleAns*>(
               &_SimpleAns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SimpleAns& a, SimpleAns& b) {
    a.Swap(&b);
  }
  inline void Swap(SimpleAns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimpleAns* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimpleAns* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SimpleAns>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SimpleAns& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SimpleAns& from) {
    SimpleAns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimpleAns* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SimpleAns";
  }
  protected:
  explicit SimpleAns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBandFieldNumber = 1,
    kAlbumFieldNumber = 2,
    kSongFieldNumber = 3,
    kConcertFieldNumber = 4,
    kMusicianFieldNumber = 5,
    kMembershipFieldNumber = 6,
  };
  // .Band band = 1;
  bool has_band() const;
  private:
  bool _internal_has_band() const;
  public:
  void clear_band();
  const ::Band& band() const;
  PROTOBUF_NODISCARD ::Band* release_band();
  ::Band* mutable_band();
  void set_allocated_band(::Band* band);
  private:
  const ::Band& _internal_band() const;
  ::Band* _internal_mutable_band();
  public:
  void unsafe_arena_set_allocated_band(
      ::Band* band);
  ::Band* unsafe_arena_release_band();

  // .Album album = 2;
  bool has_album() const;
  private:
  bool _internal_has_album() const;
  public:
  void clear_album();
  const ::Album& album() const;
  PROTOBUF_NODISCARD ::Album* release_album();
  ::Album* mutable_album();
  void set_allocated_album(::Album* album);
  private:
  const ::Album& _internal_album() const;
  ::Album* _internal_mutable_album();
  public:
  void unsafe_arena_set_allocated_album(
      ::Album* album);
  ::Album* unsafe_arena_release_album();

  // .Song song = 3;
  bool has_song() const;
  private:
  bool _internal_has_song() const;
  public:
  void clear_song();
  const ::Song& song() const;
  PROTOBUF_NODISCARD ::Song* release_song();
  ::Song* mutable_song();
  void set_allocated_song(::Song* song);
  private:
  const ::Song& _internal_song() const;
  ::Song* _internal_mutable_song();
  public:
  void unsafe_arena_set_allocated_song(
      ::Song* song);
  ::Song* unsafe_arena_release_song();

  // .Concert concert = 4;
  bool has_concert() const;
  private:
  bool _internal_has_concert() const;
  public:
  void clear_concert();
  const ::Concert& concert() const;
  PROTOBUF_NODISCARD ::Concert* release_concert();
  ::Concert* mutable_concert();
  void set_allocated_concert(::Concert* concert);
  private:
  const ::Concert& _internal_concert() const;
  ::Concert* _internal_mutable_concert();
  public:
  void unsafe_arena_set_allocated_concert(
      ::Concert* concert);
  ::Concert* unsafe_arena_release_concert();

  // .Musician musician = 5;
  bool has_musician() const;
  private:
  bool _internal_has_musician() const;
  public:
  void clear_musician();
  const ::Musician& musician() const;
  PROTOBUF_NODISCARD ::Musician* release_musician();
  ::Musician* mutable_musician();
  void set_allocated_musician(::Musician* musician);
  private:
  const ::Musician& _internal_musician() const;
  ::Musician* _internal_mutable_musician();
  public:
  void unsafe_arena_set_allocated_musician(
      ::Musician* musician);
  ::Musician* unsafe_arena_release_musician();

  // .Membership membership = 6;
  bool has_membership() const;
  private:
  bool _internal_has_membership() const;
  public:
  void clear_membership();
  const ::Membership& membership() const;
  PROTOBUF_NODISCARD ::Membership* release_membership();
  ::Membership* mutable_membership();
  void set_allocated_membership(::Membership* membership);
  private:
  const ::Membership& _internal_membership() const;
  ::Membership* _internal_mutable_membership();
  public:
  void unsafe_arena_set_allocated_membership(
      ::Membership* membership);
  ::Membership* unsafe_arena_release_membership();

  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:SimpleAns)
 private:
  class _Internal;
  void set_has_band();
  void set_has_album();
  void set_has_song();
  void set_has_concert();
  void set_has_musician();
  void set_has_membership();

  inline bool has_msg() const;
  inline void clear_has_msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MsgUnion {
      constexpr MsgUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Band* band_;
      ::Album* album_;
      ::Song* song_;
      ::Concert* concert_;
      ::Musician* musician_;
      ::Membership* membership_;
    } msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class StreamAns final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StreamAns) */ {
 public:
  inline StreamAns() : StreamAns(nullptr) {}
  ~StreamAns() override;
  explicit PROTOBUF_CONSTEXPR StreamAns(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamAns(const StreamAns& from);
  StreamAns(StreamAns&& from) noexcept
    : StreamAns() {
    *this = ::std::move(from);
  }

  inline StreamAns& operator=(const StreamAns& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamAns& operator=(StreamAns&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamAns& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamAns* internal_default_instance() {
    return reinterpret_cast<const StreamAns*>(
               &_StreamAns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StreamAns& a, StreamAns& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamAns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamAns* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamAns* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamAns>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamAns& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamAns& from) {
    StreamAns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamAns* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StreamAns";
  }
  protected:
  explicit StreamAns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kIsFinalFieldNumber = 2,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // bool isFinal = 2;
  void clear_isfinal();
  bool isfinal() const;
  void set_isfinal(bool value);
  private:
  bool _internal_isfinal() const;
  void _internal_set_isfinal(bool value);
  public:

  // @@protoc_insertion_point(class_scope:StreamAns)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    bool isfinal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Membership final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Membership) */ {
 public:
  inline Membership() : Membership(nullptr) {}
  ~Membership() override;
  explicit PROTOBUF_CONSTEXPR Membership(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Membership(const Membership& from);
  Membership(Membership&& from) noexcept
    : Membership() {
    *this = ::std::move(from);
  }

  inline Membership& operator=(const Membership& from) {
    CopyFrom(from);
    return *this;
  }
  inline Membership& operator=(Membership&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Membership& default_instance() {
    return *internal_default_instance();
  }
  static inline const Membership* internal_default_instance() {
    return reinterpret_cast<const Membership*>(
               &_Membership_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Membership& a, Membership& b) {
    a.Swap(&b);
  }
  inline void Swap(Membership* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Membership* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Membership* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Membership>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Membership& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Membership& from) {
    Membership::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Membership* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Membership";
  }
  protected:
  explicit Membership(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMusNameFieldNumber = 1,
    kBandNameFieldNumber = 2,
    kUnixEntryDateFieldNumber = 3,
    kUnixQuitDateFieldNumber = 4,
  };
  // string musName = 1;
  void clear_musname();
  const std::string& musname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_musname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_musname();
  PROTOBUF_NODISCARD std::string* release_musname();
  void set_allocated_musname(std::string* musname);
  private:
  const std::string& _internal_musname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_musname(const std::string& value);
  std::string* _internal_mutable_musname();
  public:

  // string bandName = 2;
  void clear_bandname();
  const std::string& bandname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bandname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bandname();
  PROTOBUF_NODISCARD std::string* release_bandname();
  void set_allocated_bandname(std::string* bandname);
  private:
  const std::string& _internal_bandname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bandname(const std::string& value);
  std::string* _internal_mutable_bandname();
  public:

  // int64 unixEntryDate = 3;
  void clear_unixentrydate();
  int64_t unixentrydate() const;
  void set_unixentrydate(int64_t value);
  private:
  int64_t _internal_unixentrydate() const;
  void _internal_set_unixentrydate(int64_t value);
  public:

  // int64 unixQuitDate = 4;
  void clear_unixquitdate();
  int64_t unixquitdate() const;
  void set_unixquitdate(int64_t value);
  private:
  int64_t _internal_unixquitdate() const;
  void _internal_set_unixquitdate(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Membership)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr musname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bandname_;
    int64_t unixentrydate_;
    int64_t unixquitdate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Concert final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Concert) */ {
 public:
  inline Concert() : Concert(nullptr) {}
  ~Concert() override;
  explicit PROTOBUF_CONSTEXPR Concert(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Concert(const Concert& from);
  Concert(Concert&& from) noexcept
    : Concert() {
    *this = ::std::move(from);
  }

  inline Concert& operator=(const Concert& from) {
    CopyFrom(from);
    return *this;
  }
  inline Concert& operator=(Concert&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Concert& default_instance() {
    return *internal_default_instance();
  }
  static inline const Concert* internal_default_instance() {
    return reinterpret_cast<const Concert*>(
               &_Concert_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Concert& a, Concert& b) {
    a.Swap(&b);
  }
  inline void Swap(Concert* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Concert* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Concert* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Concert>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Concert& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Concert& from) {
    Concert::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Concert* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Concert";
  }
  protected:
  explicit Concert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBandNamesFieldNumber = 5,
    kDescriptionFieldNumber = 2,
    kLocationFieldNumber = 4,
    kUnixDateTimeFieldNumber = 3,
    kCapacityFieldNumber = 1,
  };
  // repeated string bandNames = 5;
  int bandnames_size() const;
  private:
  int _internal_bandnames_size() const;
  public:
  void clear_bandnames();
  const std::string& bandnames(int index) const;
  std::string* mutable_bandnames(int index);
  void set_bandnames(int index, const std::string& value);
  void set_bandnames(int index, std::string&& value);
  void set_bandnames(int index, const char* value);
  void set_bandnames(int index, const char* value, size_t size);
  std::string* add_bandnames();
  void add_bandnames(const std::string& value);
  void add_bandnames(std::string&& value);
  void add_bandnames(const char* value);
  void add_bandnames(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& bandnames() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_bandnames();
  private:
  const std::string& _internal_bandnames(int index) const;
  std::string* _internal_add_bandnames();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string location = 4;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // int64 unixDateTime = 3;
  void clear_unixdatetime();
  int64_t unixdatetime() const;
  void set_unixdatetime(int64_t value);
  private:
  int64_t _internal_unixdatetime() const;
  void _internal_set_unixdatetime(int64_t value);
  public:

  // int32 capacity = 1;
  void clear_capacity();
  int32_t capacity() const;
  void set_capacity(int32_t value);
  private:
  int32_t _internal_capacity() const;
  void _internal_set_capacity(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Concert)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> bandnames_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    int64_t unixdatetime_;
    int32_t capacity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Band final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Band) */ {
 public:
  inline Band() : Band(nullptr) {}
  ~Band() override;
  explicit PROTOBUF_CONSTEXPR Band(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Band(const Band& from);
  Band(Band&& from) noexcept
    : Band() {
    *this = ::std::move(from);
  }

  inline Band& operator=(const Band& from) {
    CopyFrom(from);
    return *this;
  }
  inline Band& operator=(Band&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Band& default_instance() {
    return *internal_default_instance();
  }
  static inline const Band* internal_default_instance() {
    return reinterpret_cast<const Band*>(
               &_Band_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Band& a, Band& b) {
    a.Swap(&b);
  }
  inline void Swap(Band* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Band* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Band* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Band>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Band& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Band& from) {
    Band::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Band* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Band";
  }
  protected:
  explicit Band(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlbumNamesFieldNumber = 6,
    kParticipantsFieldNumber = 7,
    kConcertsFieldNumber = 8,
    kBandNameFieldNumber = 1,
    kDescriptionFieldNumber = 5,
    kUnixFoundDateFieldNumber = 3,
    kUnixTermDateFieldNumber = 4,
    kObjIdFieldNumber = 9,
    kGenreFieldNumber = 2,
  };
  // repeated string albumNames = 6;
  int albumnames_size() const;
  private:
  int _internal_albumnames_size() const;
  public:
  void clear_albumnames();
  const std::string& albumnames(int index) const;
  std::string* mutable_albumnames(int index);
  void set_albumnames(int index, const std::string& value);
  void set_albumnames(int index, std::string&& value);
  void set_albumnames(int index, const char* value);
  void set_albumnames(int index, const char* value, size_t size);
  std::string* add_albumnames();
  void add_albumnames(const std::string& value);
  void add_albumnames(std::string&& value);
  void add_albumnames(const char* value);
  void add_albumnames(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& albumnames() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_albumnames();
  private:
  const std::string& _internal_albumnames(int index) const;
  std::string* _internal_add_albumnames();
  public:

  // repeated .Membership participants = 7;
  int participants_size() const;
  private:
  int _internal_participants_size() const;
  public:
  void clear_participants();
  ::Membership* mutable_participants(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Membership >*
      mutable_participants();
  private:
  const ::Membership& _internal_participants(int index) const;
  ::Membership* _internal_add_participants();
  public:
  const ::Membership& participants(int index) const;
  ::Membership* add_participants();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Membership >&
      participants() const;

  // repeated .Concert concerts = 8;
  int concerts_size() const;
  private:
  int _internal_concerts_size() const;
  public:
  void clear_concerts();
  ::Concert* mutable_concerts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Concert >*
      mutable_concerts();
  private:
  const ::Concert& _internal_concerts(int index) const;
  ::Concert* _internal_add_concerts();
  public:
  const ::Concert& concerts(int index) const;
  ::Concert* add_concerts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Concert >&
      concerts() const;

  // string bandName = 1;
  void clear_bandname();
  const std::string& bandname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bandname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bandname();
  PROTOBUF_NODISCARD std::string* release_bandname();
  void set_allocated_bandname(std::string* bandname);
  private:
  const std::string& _internal_bandname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bandname(const std::string& value);
  std::string* _internal_mutable_bandname();
  public:

  // string description = 5;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // int64 unixFoundDate = 3;
  void clear_unixfounddate();
  int64_t unixfounddate() const;
  void set_unixfounddate(int64_t value);
  private:
  int64_t _internal_unixfounddate() const;
  void _internal_set_unixfounddate(int64_t value);
  public:

  // int64 unixTermDate = 4;
  void clear_unixtermdate();
  int64_t unixtermdate() const;
  void set_unixtermdate(int64_t value);
  private:
  int64_t _internal_unixtermdate() const;
  void _internal_set_unixtermdate(int64_t value);
  public:

  // int64 objId = 9;
  void clear_objid();
  int64_t objid() const;
  void set_objid(int64_t value);
  private:
  int64_t _internal_objid() const;
  void _internal_set_objid(int64_t value);
  public:

  // .Genre genre = 2;
  void clear_genre();
  ::Genre genre() const;
  void set_genre(::Genre value);
  private:
  ::Genre _internal_genre() const;
  void _internal_set_genre(::Genre value);
  public:

  // @@protoc_insertion_point(class_scope:Band)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> albumnames_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Membership > participants_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Concert > concerts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bandname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    int64_t unixfounddate_;
    int64_t unixtermdate_;
    int64_t objid_;
    int genre_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Song final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Song) */ {
 public:
  inline Song() : Song(nullptr) {}
  ~Song() override;
  explicit PROTOBUF_CONSTEXPR Song(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Song(const Song& from);
  Song(Song&& from) noexcept
    : Song() {
    *this = ::std::move(from);
  }

  inline Song& operator=(const Song& from) {
    CopyFrom(from);
    return *this;
  }
  inline Song& operator=(Song&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Song& default_instance() {
    return *internal_default_instance();
  }
  static inline const Song* internal_default_instance() {
    return reinterpret_cast<const Song*>(
               &_Song_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Song& a, Song& b) {
    a.Swap(&b);
  }
  inline void Swap(Song* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Song* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Song* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Song>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Song& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Song& from) {
    Song::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Song* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Song";
  }
  protected:
  explicit Song(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSongNameFieldNumber = 1,
    kAlbumNameFieldNumber = 3,
    kBandNameFieldNumber = 4,
    kObjIdFieldNumber = 5,
    kLengthSecFieldNumber = 2,
  };
  // string songName = 1;
  void clear_songname();
  const std::string& songname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_songname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_songname();
  PROTOBUF_NODISCARD std::string* release_songname();
  void set_allocated_songname(std::string* songname);
  private:
  const std::string& _internal_songname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_songname(const std::string& value);
  std::string* _internal_mutable_songname();
  public:

  // string albumName = 3;
  void clear_albumname();
  const std::string& albumname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_albumname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_albumname();
  PROTOBUF_NODISCARD std::string* release_albumname();
  void set_allocated_albumname(std::string* albumname);
  private:
  const std::string& _internal_albumname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_albumname(const std::string& value);
  std::string* _internal_mutable_albumname();
  public:

  // string bandName = 4;
  void clear_bandname();
  const std::string& bandname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bandname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bandname();
  PROTOBUF_NODISCARD std::string* release_bandname();
  void set_allocated_bandname(std::string* bandname);
  private:
  const std::string& _internal_bandname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bandname(const std::string& value);
  std::string* _internal_mutable_bandname();
  public:

  // int64 objId = 5;
  void clear_objid();
  int64_t objid() const;
  void set_objid(int64_t value);
  private:
  int64_t _internal_objid() const;
  void _internal_set_objid(int64_t value);
  public:

  // int32 lengthSec = 2;
  void clear_lengthsec();
  int32_t lengthsec() const;
  void set_lengthsec(int32_t value);
  private:
  int32_t _internal_lengthsec() const;
  void _internal_set_lengthsec(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Song)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr songname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr albumname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bandname_;
    int64_t objid_;
    int32_t lengthsec_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Album final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Album) */ {
 public:
  inline Album() : Album(nullptr) {}
  ~Album() override;
  explicit PROTOBUF_CONSTEXPR Album(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Album(const Album& from);
  Album(Album&& from) noexcept
    : Album() {
    *this = ::std::move(from);
  }

  inline Album& operator=(const Album& from) {
    CopyFrom(from);
    return *this;
  }
  inline Album& operator=(Album&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Album& default_instance() {
    return *internal_default_instance();
  }
  static inline const Album* internal_default_instance() {
    return reinterpret_cast<const Album*>(
               &_Album_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Album& a, Album& b) {
    a.Swap(&b);
  }
  inline void Swap(Album* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Album* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Album* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Album>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Album& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Album& from) {
    Album::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Album* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Album";
  }
  protected:
  explicit Album(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSongsFieldNumber = 3,
    kTitleFieldNumber = 1,
    kBandNameFieldNumber = 4,
    kUnixReleaseDateFieldNumber = 2,
  };
  // repeated .Song songs = 3;
  int songs_size() const;
  private:
  int _internal_songs_size() const;
  public:
  void clear_songs();
  ::Song* mutable_songs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Song >*
      mutable_songs();
  private:
  const ::Song& _internal_songs(int index) const;
  ::Song* _internal_add_songs();
  public:
  const ::Song& songs(int index) const;
  ::Song* add_songs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Song >&
      songs() const;

  // string title = 1;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string bandName = 4;
  void clear_bandname();
  const std::string& bandname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bandname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bandname();
  PROTOBUF_NODISCARD std::string* release_bandname();
  void set_allocated_bandname(std::string* bandname);
  private:
  const std::string& _internal_bandname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bandname(const std::string& value);
  std::string* _internal_mutable_bandname();
  public:

  // int64 unixReleaseDate = 2;
  void clear_unixreleasedate();
  int64_t unixreleasedate() const;
  void set_unixreleasedate(int64_t value);
  private:
  int64_t _internal_unixreleasedate() const;
  void _internal_set_unixreleasedate(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Album)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Song > songs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bandname_;
    int64_t unixreleasedate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Musician final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Musician) */ {
 public:
  inline Musician() : Musician(nullptr) {}
  ~Musician() override;
  explicit PROTOBUF_CONSTEXPR Musician(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Musician(const Musician& from);
  Musician(Musician&& from) noexcept
    : Musician() {
    *this = ::std::move(from);
  }

  inline Musician& operator=(const Musician& from) {
    CopyFrom(from);
    return *this;
  }
  inline Musician& operator=(Musician&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Musician& default_instance() {
    return *internal_default_instance();
  }
  static inline const Musician* internal_default_instance() {
    return reinterpret_cast<const Musician*>(
               &_Musician_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Musician& a, Musician& b) {
    a.Swap(&b);
  }
  inline void Swap(Musician* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Musician* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Musician* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Musician>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Musician& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Musician& from) {
    Musician::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Musician* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Musician";
  }
  protected:
  explicit Musician(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembershipsFieldNumber = 4,
    kMusNameFieldNumber = 1,
    kBioFieldNumber = 3,
    kUnixDateOfBirthFieldNumber = 2,
    kObjIdFieldNumber = 5,
  };
  // repeated .Membership memberships = 4;
  int memberships_size() const;
  private:
  int _internal_memberships_size() const;
  public:
  void clear_memberships();
  ::Membership* mutable_memberships(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Membership >*
      mutable_memberships();
  private:
  const ::Membership& _internal_memberships(int index) const;
  ::Membership* _internal_add_memberships();
  public:
  const ::Membership& memberships(int index) const;
  ::Membership* add_memberships();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Membership >&
      memberships() const;

  // string musName = 1;
  void clear_musname();
  const std::string& musname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_musname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_musname();
  PROTOBUF_NODISCARD std::string* release_musname();
  void set_allocated_musname(std::string* musname);
  private:
  const std::string& _internal_musname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_musname(const std::string& value);
  std::string* _internal_mutable_musname();
  public:

  // string bio = 3;
  void clear_bio();
  const std::string& bio() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bio(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bio();
  PROTOBUF_NODISCARD std::string* release_bio();
  void set_allocated_bio(std::string* bio);
  private:
  const std::string& _internal_bio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bio(const std::string& value);
  std::string* _internal_mutable_bio();
  public:

  // int64 unixDateOfBirth = 2;
  void clear_unixdateofbirth();
  int64_t unixdateofbirth() const;
  void set_unixdateofbirth(int64_t value);
  private:
  int64_t _internal_unixdateofbirth() const;
  void _internal_set_unixdateofbirth(int64_t value);
  public:

  // int64 objId = 5;
  void clear_objid();
  int64_t objid() const;
  void set_objid(int64_t value);
  private:
  int64_t _internal_objid() const;
  void _internal_set_objid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Musician)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Membership > memberships_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr musname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bio_;
    int64_t unixdateofbirth_;
    int64_t objid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Request

// uint64 reqId = 1;
inline void Request::clear_reqid() {
  _impl_.reqid_ = uint64_t{0u};
}
inline uint64_t Request::_internal_reqid() const {
  return _impl_.reqid_;
}
inline uint64_t Request::reqid() const {
  // @@protoc_insertion_point(field_get:Request.reqId)
  return _internal_reqid();
}
inline void Request::_internal_set_reqid(uint64_t value) {
  
  _impl_.reqid_ = value;
}
inline void Request::set_reqid(uint64_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:Request.reqId)
}

// bool cancel = 3;
inline void Request::clear_cancel() {
  _impl_.cancel_ = false;
}
inline bool Request::_internal_cancel() const {
  return _impl_.cancel_;
}
inline bool Request::cancel() const {
  // @@protoc_insertion_point(field_get:Request.cancel)
  return _internal_cancel();
}
inline void Request::_internal_set_cancel(bool value) {
  
  _impl_.cancel_ = value;
}
inline void Request::set_cancel(bool value) {
  _internal_set_cancel(value);
  // @@protoc_insertion_point(field_set:Request.cancel)
}

// .TableReq tableReq = 4;
inline bool Request::_internal_has_tablereq() const {
  return msg_case() == kTableReq;
}
inline bool Request::has_tablereq() const {
  return _internal_has_tablereq();
}
inline void Request::set_has_tablereq() {
  _impl_._oneof_case_[0] = kTableReq;
}
inline void Request::clear_tablereq() {
  if (_internal_has_tablereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.msg_.tablereq_;
    }
    clear_has_msg();
  }
}
inline ::TableReq* Request::release_tablereq() {
  // @@protoc_insertion_point(field_release:Request.tableReq)
  if (_internal_has_tablereq()) {
    clear_has_msg();
    ::TableReq* temp = _impl_.msg_.tablereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.tablereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TableReq& Request::_internal_tablereq() const {
  return _internal_has_tablereq()
      ? *_impl_.msg_.tablereq_
      : reinterpret_cast< ::TableReq&>(::_TableReq_default_instance_);
}
inline const ::TableReq& Request::tablereq() const {
  // @@protoc_insertion_point(field_get:Request.tableReq)
  return _internal_tablereq();
}
inline ::TableReq* Request::unsafe_arena_release_tablereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Request.tableReq)
  if (_internal_has_tablereq()) {
    clear_has_msg();
    ::TableReq* temp = _impl_.msg_.tablereq_;
    _impl_.msg_.tablereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_tablereq(::TableReq* tablereq) {
  clear_msg();
  if (tablereq) {
    set_has_tablereq();
    _impl_.msg_.tablereq_ = tablereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Request.tableReq)
}
inline ::TableReq* Request::_internal_mutable_tablereq() {
  if (!_internal_has_tablereq()) {
    clear_msg();
    set_has_tablereq();
    _impl_.msg_.tablereq_ = CreateMaybeMessage< ::TableReq >(GetArenaForAllocation());
  }
  return _impl_.msg_.tablereq_;
}
inline ::TableReq* Request::mutable_tablereq() {
  ::TableReq* _msg = _internal_mutable_tablereq();
  // @@protoc_insertion_point(field_mutable:Request.tableReq)
  return _msg;
}

// .SimpleReq simpleReq = 5;
inline bool Request::_internal_has_simplereq() const {
  return msg_case() == kSimpleReq;
}
inline bool Request::has_simplereq() const {
  return _internal_has_simplereq();
}
inline void Request::set_has_simplereq() {
  _impl_._oneof_case_[0] = kSimpleReq;
}
inline void Request::clear_simplereq() {
  if (_internal_has_simplereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.msg_.simplereq_;
    }
    clear_has_msg();
  }
}
inline ::SimpleReq* Request::release_simplereq() {
  // @@protoc_insertion_point(field_release:Request.simpleReq)
  if (_internal_has_simplereq()) {
    clear_has_msg();
    ::SimpleReq* temp = _impl_.msg_.simplereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.simplereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SimpleReq& Request::_internal_simplereq() const {
  return _internal_has_simplereq()
      ? *_impl_.msg_.simplereq_
      : reinterpret_cast< ::SimpleReq&>(::_SimpleReq_default_instance_);
}
inline const ::SimpleReq& Request::simplereq() const {
  // @@protoc_insertion_point(field_get:Request.simpleReq)
  return _internal_simplereq();
}
inline ::SimpleReq* Request::unsafe_arena_release_simplereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Request.simpleReq)
  if (_internal_has_simplereq()) {
    clear_has_msg();
    ::SimpleReq* temp = _impl_.msg_.simplereq_;
    _impl_.msg_.simplereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_simplereq(::SimpleReq* simplereq) {
  clear_msg();
  if (simplereq) {
    set_has_simplereq();
    _impl_.msg_.simplereq_ = simplereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Request.simpleReq)
}
inline ::SimpleReq* Request::_internal_mutable_simplereq() {
  if (!_internal_has_simplereq()) {
    clear_msg();
    set_has_simplereq();
    _impl_.msg_.simplereq_ = CreateMaybeMessage< ::SimpleReq >(GetArenaForAllocation());
  }
  return _impl_.msg_.simplereq_;
}
inline ::SimpleReq* Request::mutable_simplereq() {
  ::SimpleReq* _msg = _internal_mutable_simplereq();
  // @@protoc_insertion_point(field_mutable:Request.simpleReq)
  return _msg;
}

// .StreamReq streamReq = 6;
inline bool Request::_internal_has_streamreq() const {
  return msg_case() == kStreamReq;
}
inline bool Request::has_streamreq() const {
  return _internal_has_streamreq();
}
inline void Request::set_has_streamreq() {
  _impl_._oneof_case_[0] = kStreamReq;
}
inline void Request::clear_streamreq() {
  if (_internal_has_streamreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.msg_.streamreq_;
    }
    clear_has_msg();
  }
}
inline ::StreamReq* Request::release_streamreq() {
  // @@protoc_insertion_point(field_release:Request.streamReq)
  if (_internal_has_streamreq()) {
    clear_has_msg();
    ::StreamReq* temp = _impl_.msg_.streamreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.streamreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::StreamReq& Request::_internal_streamreq() const {
  return _internal_has_streamreq()
      ? *_impl_.msg_.streamreq_
      : reinterpret_cast< ::StreamReq&>(::_StreamReq_default_instance_);
}
inline const ::StreamReq& Request::streamreq() const {
  // @@protoc_insertion_point(field_get:Request.streamReq)
  return _internal_streamreq();
}
inline ::StreamReq* Request::unsafe_arena_release_streamreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Request.streamReq)
  if (_internal_has_streamreq()) {
    clear_has_msg();
    ::StreamReq* temp = _impl_.msg_.streamreq_;
    _impl_.msg_.streamreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_streamreq(::StreamReq* streamreq) {
  clear_msg();
  if (streamreq) {
    set_has_streamreq();
    _impl_.msg_.streamreq_ = streamreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Request.streamReq)
}
inline ::StreamReq* Request::_internal_mutable_streamreq() {
  if (!_internal_has_streamreq()) {
    clear_msg();
    set_has_streamreq();
    _impl_.msg_.streamreq_ = CreateMaybeMessage< ::StreamReq >(GetArenaForAllocation());
  }
  return _impl_.msg_.streamreq_;
}
inline ::StreamReq* Request::mutable_streamreq() {
  ::StreamReq* _msg = _internal_mutable_streamreq();
  // @@protoc_insertion_point(field_mutable:Request.streamReq)
  return _msg;
}

inline bool Request::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void Request::clear_has_msg() {
  _impl_._oneof_case_[0] = MSG_NOT_SET;
}
inline Request::MsgCase Request::msg_case() const {
  return Request::MsgCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Answer

// uint64 reqId = 1;
inline void Answer::clear_reqid() {
  _impl_.reqid_ = uint64_t{0u};
}
inline uint64_t Answer::_internal_reqid() const {
  return _impl_.reqid_;
}
inline uint64_t Answer::reqid() const {
  // @@protoc_insertion_point(field_get:Answer.reqId)
  return _internal_reqid();
}
inline void Answer::_internal_set_reqid(uint64_t value) {
  
  _impl_.reqid_ = value;
}
inline void Answer::set_reqid(uint64_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:Answer.reqId)
}

// bool cancel = 2;
inline void Answer::clear_cancel() {
  _impl_.cancel_ = false;
}
inline bool Answer::_internal_cancel() const {
  return _impl_.cancel_;
}
inline bool Answer::cancel() const {
  // @@protoc_insertion_point(field_get:Answer.cancel)
  return _internal_cancel();
}
inline void Answer::_internal_set_cancel(bool value) {
  
  _impl_.cancel_ = value;
}
inline void Answer::set_cancel(bool value) {
  _internal_set_cancel(value);
  // @@protoc_insertion_point(field_set:Answer.cancel)
}

// .TableAns tableAns = 3;
inline bool Answer::_internal_has_tableans() const {
  return msg_case() == kTableAns;
}
inline bool Answer::has_tableans() const {
  return _internal_has_tableans();
}
inline void Answer::set_has_tableans() {
  _impl_._oneof_case_[0] = kTableAns;
}
inline void Answer::clear_tableans() {
  if (_internal_has_tableans()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.msg_.tableans_;
    }
    clear_has_msg();
  }
}
inline ::TableAns* Answer::release_tableans() {
  // @@protoc_insertion_point(field_release:Answer.tableAns)
  if (_internal_has_tableans()) {
    clear_has_msg();
    ::TableAns* temp = _impl_.msg_.tableans_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.tableans_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TableAns& Answer::_internal_tableans() const {
  return _internal_has_tableans()
      ? *_impl_.msg_.tableans_
      : reinterpret_cast< ::TableAns&>(::_TableAns_default_instance_);
}
inline const ::TableAns& Answer::tableans() const {
  // @@protoc_insertion_point(field_get:Answer.tableAns)
  return _internal_tableans();
}
inline ::TableAns* Answer::unsafe_arena_release_tableans() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Answer.tableAns)
  if (_internal_has_tableans()) {
    clear_has_msg();
    ::TableAns* temp = _impl_.msg_.tableans_;
    _impl_.msg_.tableans_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Answer::unsafe_arena_set_allocated_tableans(::TableAns* tableans) {
  clear_msg();
  if (tableans) {
    set_has_tableans();
    _impl_.msg_.tableans_ = tableans;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Answer.tableAns)
}
inline ::TableAns* Answer::_internal_mutable_tableans() {
  if (!_internal_has_tableans()) {
    clear_msg();
    set_has_tableans();
    _impl_.msg_.tableans_ = CreateMaybeMessage< ::TableAns >(GetArenaForAllocation());
  }
  return _impl_.msg_.tableans_;
}
inline ::TableAns* Answer::mutable_tableans() {
  ::TableAns* _msg = _internal_mutable_tableans();
  // @@protoc_insertion_point(field_mutable:Answer.tableAns)
  return _msg;
}

// .SimpleAns simpleAns = 4;
inline bool Answer::_internal_has_simpleans() const {
  return msg_case() == kSimpleAns;
}
inline bool Answer::has_simpleans() const {
  return _internal_has_simpleans();
}
inline void Answer::set_has_simpleans() {
  _impl_._oneof_case_[0] = kSimpleAns;
}
inline void Answer::clear_simpleans() {
  if (_internal_has_simpleans()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.msg_.simpleans_;
    }
    clear_has_msg();
  }
}
inline ::SimpleAns* Answer::release_simpleans() {
  // @@protoc_insertion_point(field_release:Answer.simpleAns)
  if (_internal_has_simpleans()) {
    clear_has_msg();
    ::SimpleAns* temp = _impl_.msg_.simpleans_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.simpleans_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SimpleAns& Answer::_internal_simpleans() const {
  return _internal_has_simpleans()
      ? *_impl_.msg_.simpleans_
      : reinterpret_cast< ::SimpleAns&>(::_SimpleAns_default_instance_);
}
inline const ::SimpleAns& Answer::simpleans() const {
  // @@protoc_insertion_point(field_get:Answer.simpleAns)
  return _internal_simpleans();
}
inline ::SimpleAns* Answer::unsafe_arena_release_simpleans() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Answer.simpleAns)
  if (_internal_has_simpleans()) {
    clear_has_msg();
    ::SimpleAns* temp = _impl_.msg_.simpleans_;
    _impl_.msg_.simpleans_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Answer::unsafe_arena_set_allocated_simpleans(::SimpleAns* simpleans) {
  clear_msg();
  if (simpleans) {
    set_has_simpleans();
    _impl_.msg_.simpleans_ = simpleans;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Answer.simpleAns)
}
inline ::SimpleAns* Answer::_internal_mutable_simpleans() {
  if (!_internal_has_simpleans()) {
    clear_msg();
    set_has_simpleans();
    _impl_.msg_.simpleans_ = CreateMaybeMessage< ::SimpleAns >(GetArenaForAllocation());
  }
  return _impl_.msg_.simpleans_;
}
inline ::SimpleAns* Answer::mutable_simpleans() {
  ::SimpleAns* _msg = _internal_mutable_simpleans();
  // @@protoc_insertion_point(field_mutable:Answer.simpleAns)
  return _msg;
}

// .StreamAns streamAns = 5;
inline bool Answer::_internal_has_streamans() const {
  return msg_case() == kStreamAns;
}
inline bool Answer::has_streamans() const {
  return _internal_has_streamans();
}
inline void Answer::set_has_streamans() {
  _impl_._oneof_case_[0] = kStreamAns;
}
inline void Answer::clear_streamans() {
  if (_internal_has_streamans()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.msg_.streamans_;
    }
    clear_has_msg();
  }
}
inline ::StreamAns* Answer::release_streamans() {
  // @@protoc_insertion_point(field_release:Answer.streamAns)
  if (_internal_has_streamans()) {
    clear_has_msg();
    ::StreamAns* temp = _impl_.msg_.streamans_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.streamans_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::StreamAns& Answer::_internal_streamans() const {
  return _internal_has_streamans()
      ? *_impl_.msg_.streamans_
      : reinterpret_cast< ::StreamAns&>(::_StreamAns_default_instance_);
}
inline const ::StreamAns& Answer::streamans() const {
  // @@protoc_insertion_point(field_get:Answer.streamAns)
  return _internal_streamans();
}
inline ::StreamAns* Answer::unsafe_arena_release_streamans() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Answer.streamAns)
  if (_internal_has_streamans()) {
    clear_has_msg();
    ::StreamAns* temp = _impl_.msg_.streamans_;
    _impl_.msg_.streamans_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Answer::unsafe_arena_set_allocated_streamans(::StreamAns* streamans) {
  clear_msg();
  if (streamans) {
    set_has_streamans();
    _impl_.msg_.streamans_ = streamans;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Answer.streamAns)
}
inline ::StreamAns* Answer::_internal_mutable_streamans() {
  if (!_internal_has_streamans()) {
    clear_msg();
    set_has_streamans();
    _impl_.msg_.streamans_ = CreateMaybeMessage< ::StreamAns >(GetArenaForAllocation());
  }
  return _impl_.msg_.streamans_;
}
inline ::StreamAns* Answer::mutable_streamans() {
  ::StreamAns* _msg = _internal_mutable_streamans();
  // @@protoc_insertion_point(field_mutable:Answer.streamAns)
  return _msg;
}

inline bool Answer::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void Answer::clear_has_msg() {
  _impl_._oneof_case_[0] = MSG_NOT_SET;
}
inline Answer::MsgCase Answer::msg_case() const {
  return Answer::MsgCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TableReq

// uint32 first = 1;
inline void TableReq::clear_first() {
  _impl_.first_ = 0u;
}
inline uint32_t TableReq::_internal_first() const {
  return _impl_.first_;
}
inline uint32_t TableReq::first() const {
  // @@protoc_insertion_point(field_get:TableReq.first)
  return _internal_first();
}
inline void TableReq::_internal_set_first(uint32_t value) {
  
  _impl_.first_ = value;
}
inline void TableReq::set_first(uint32_t value) {
  _internal_set_first(value);
  // @@protoc_insertion_point(field_set:TableReq.first)
}

// uint32 last = 2;
inline void TableReq::clear_last() {
  _impl_.last_ = 0u;
}
inline uint32_t TableReq::_internal_last() const {
  return _impl_.last_;
}
inline uint32_t TableReq::last() const {
  // @@protoc_insertion_point(field_get:TableReq.last)
  return _internal_last();
}
inline void TableReq::_internal_set_last(uint32_t value) {
  
  _impl_.last_ = value;
}
inline void TableReq::set_last(uint32_t value) {
  _internal_set_last(value);
  // @@protoc_insertion_point(field_set:TableReq.last)
}

// string filter = 3;
inline void TableReq::clear_filter() {
  _impl_.filter_.ClearToEmpty();
}
inline const std::string& TableReq::filter() const {
  // @@protoc_insertion_point(field_get:TableReq.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableReq::set_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TableReq.filter)
}
inline std::string* TableReq::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:TableReq.filter)
  return _s;
}
inline const std::string& TableReq::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void TableReq::_internal_set_filter(const std::string& value) {
  
  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* TableReq::_internal_mutable_filter() {
  
  return _impl_.filter_.Mutable(GetArenaForAllocation());
}
inline std::string* TableReq::release_filter() {
  // @@protoc_insertion_point(field_release:TableReq.filter)
  return _impl_.filter_.Release();
}
inline void TableReq::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  _impl_.filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_.IsDefault()) {
    _impl_.filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TableReq.filter)
}

// .EntityType type = 4;
inline void TableReq::clear_type() {
  _impl_.type_ = 0;
}
inline ::EntityType TableReq::_internal_type() const {
  return static_cast< ::EntityType >(_impl_.type_);
}
inline ::EntityType TableReq::type() const {
  // @@protoc_insertion_point(field_get:TableReq.type)
  return _internal_type();
}
inline void TableReq::_internal_set_type(::EntityType value) {
  
  _impl_.type_ = value;
}
inline void TableReq::set_type(::EntityType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TableReq.type)
}

// -------------------------------------------------------------------

// SimpleReq

// string reqString = 1;
inline void SimpleReq::clear_reqstring() {
  _impl_.reqstring_.ClearToEmpty();
}
inline const std::string& SimpleReq::reqstring() const {
  // @@protoc_insertion_point(field_get:SimpleReq.reqString)
  return _internal_reqstring();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SimpleReq::set_reqstring(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reqstring_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SimpleReq.reqString)
}
inline std::string* SimpleReq::mutable_reqstring() {
  std::string* _s = _internal_mutable_reqstring();
  // @@protoc_insertion_point(field_mutable:SimpleReq.reqString)
  return _s;
}
inline const std::string& SimpleReq::_internal_reqstring() const {
  return _impl_.reqstring_.Get();
}
inline void SimpleReq::_internal_set_reqstring(const std::string& value) {
  
  _impl_.reqstring_.Set(value, GetArenaForAllocation());
}
inline std::string* SimpleReq::_internal_mutable_reqstring() {
  
  return _impl_.reqstring_.Mutable(GetArenaForAllocation());
}
inline std::string* SimpleReq::release_reqstring() {
  // @@protoc_insertion_point(field_release:SimpleReq.reqString)
  return _impl_.reqstring_.Release();
}
inline void SimpleReq::set_allocated_reqstring(std::string* reqstring) {
  if (reqstring != nullptr) {
    
  } else {
    
  }
  _impl_.reqstring_.SetAllocated(reqstring, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reqstring_.IsDefault()) {
    _impl_.reqstring_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SimpleReq.reqString)
}

// .EntityType type = 4;
inline void SimpleReq::clear_type() {
  _impl_.type_ = 0;
}
inline ::EntityType SimpleReq::_internal_type() const {
  return static_cast< ::EntityType >(_impl_.type_);
}
inline ::EntityType SimpleReq::type() const {
  // @@protoc_insertion_point(field_get:SimpleReq.type)
  return _internal_type();
}
inline void SimpleReq::_internal_set_type(::EntityType value) {
  
  _impl_.type_ = value;
}
inline void SimpleReq::set_type(::EntityType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SimpleReq.type)
}

// -------------------------------------------------------------------

// StreamReq

// int64 objId = 1;
inline void StreamReq::clear_objid() {
  _impl_.objid_ = int64_t{0};
}
inline int64_t StreamReq::_internal_objid() const {
  return _impl_.objid_;
}
inline int64_t StreamReq::objid() const {
  // @@protoc_insertion_point(field_get:StreamReq.objId)
  return _internal_objid();
}
inline void StreamReq::_internal_set_objid(int64_t value) {
  
  _impl_.objid_ = value;
}
inline void StreamReq::set_objid(int64_t value) {
  _internal_set_objid(value);
  // @@protoc_insertion_point(field_set:StreamReq.objId)
}

// int32 suggestedSize = 2;
inline void StreamReq::clear_suggestedsize() {
  _impl_.suggestedsize_ = 0;
}
inline int32_t StreamReq::_internal_suggestedsize() const {
  return _impl_.suggestedsize_;
}
inline int32_t StreamReq::suggestedsize() const {
  // @@protoc_insertion_point(field_get:StreamReq.suggestedSize)
  return _internal_suggestedsize();
}
inline void StreamReq::_internal_set_suggestedsize(int32_t value) {
  
  _impl_.suggestedsize_ = value;
}
inline void StreamReq::set_suggestedsize(int32_t value) {
  _internal_set_suggestedsize(value);
  // @@protoc_insertion_point(field_set:StreamReq.suggestedSize)
}

// -------------------------------------------------------------------

// TableAns

// repeated .Band bands = 1;
inline int TableAns::_internal_bands_size() const {
  return _impl_.bands_.size();
}
inline int TableAns::bands_size() const {
  return _internal_bands_size();
}
inline void TableAns::clear_bands() {
  _impl_.bands_.Clear();
}
inline ::Band* TableAns::mutable_bands(int index) {
  // @@protoc_insertion_point(field_mutable:TableAns.bands)
  return _impl_.bands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Band >*
TableAns::mutable_bands() {
  // @@protoc_insertion_point(field_mutable_list:TableAns.bands)
  return &_impl_.bands_;
}
inline const ::Band& TableAns::_internal_bands(int index) const {
  return _impl_.bands_.Get(index);
}
inline const ::Band& TableAns::bands(int index) const {
  // @@protoc_insertion_point(field_get:TableAns.bands)
  return _internal_bands(index);
}
inline ::Band* TableAns::_internal_add_bands() {
  return _impl_.bands_.Add();
}
inline ::Band* TableAns::add_bands() {
  ::Band* _add = _internal_add_bands();
  // @@protoc_insertion_point(field_add:TableAns.bands)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Band >&
TableAns::bands() const {
  // @@protoc_insertion_point(field_list:TableAns.bands)
  return _impl_.bands_;
}

// repeated .Album albums = 2;
inline int TableAns::_internal_albums_size() const {
  return _impl_.albums_.size();
}
inline int TableAns::albums_size() const {
  return _internal_albums_size();
}
inline void TableAns::clear_albums() {
  _impl_.albums_.Clear();
}
inline ::Album* TableAns::mutable_albums(int index) {
  // @@protoc_insertion_point(field_mutable:TableAns.albums)
  return _impl_.albums_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Album >*
TableAns::mutable_albums() {
  // @@protoc_insertion_point(field_mutable_list:TableAns.albums)
  return &_impl_.albums_;
}
inline const ::Album& TableAns::_internal_albums(int index) const {
  return _impl_.albums_.Get(index);
}
inline const ::Album& TableAns::albums(int index) const {
  // @@protoc_insertion_point(field_get:TableAns.albums)
  return _internal_albums(index);
}
inline ::Album* TableAns::_internal_add_albums() {
  return _impl_.albums_.Add();
}
inline ::Album* TableAns::add_albums() {
  ::Album* _add = _internal_add_albums();
  // @@protoc_insertion_point(field_add:TableAns.albums)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Album >&
TableAns::albums() const {
  // @@protoc_insertion_point(field_list:TableAns.albums)
  return _impl_.albums_;
}

// repeated .Concert concerts = 3;
inline int TableAns::_internal_concerts_size() const {
  return _impl_.concerts_.size();
}
inline int TableAns::concerts_size() const {
  return _internal_concerts_size();
}
inline void TableAns::clear_concerts() {
  _impl_.concerts_.Clear();
}
inline ::Concert* TableAns::mutable_concerts(int index) {
  // @@protoc_insertion_point(field_mutable:TableAns.concerts)
  return _impl_.concerts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Concert >*
TableAns::mutable_concerts() {
  // @@protoc_insertion_point(field_mutable_list:TableAns.concerts)
  return &_impl_.concerts_;
}
inline const ::Concert& TableAns::_internal_concerts(int index) const {
  return _impl_.concerts_.Get(index);
}
inline const ::Concert& TableAns::concerts(int index) const {
  // @@protoc_insertion_point(field_get:TableAns.concerts)
  return _internal_concerts(index);
}
inline ::Concert* TableAns::_internal_add_concerts() {
  return _impl_.concerts_.Add();
}
inline ::Concert* TableAns::add_concerts() {
  ::Concert* _add = _internal_add_concerts();
  // @@protoc_insertion_point(field_add:TableAns.concerts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Concert >&
TableAns::concerts() const {
  // @@protoc_insertion_point(field_list:TableAns.concerts)
  return _impl_.concerts_;
}

// repeated .Song songs = 4;
inline int TableAns::_internal_songs_size() const {
  return _impl_.songs_.size();
}
inline int TableAns::songs_size() const {
  return _internal_songs_size();
}
inline void TableAns::clear_songs() {
  _impl_.songs_.Clear();
}
inline ::Song* TableAns::mutable_songs(int index) {
  // @@protoc_insertion_point(field_mutable:TableAns.songs)
  return _impl_.songs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Song >*
TableAns::mutable_songs() {
  // @@protoc_insertion_point(field_mutable_list:TableAns.songs)
  return &_impl_.songs_;
}
inline const ::Song& TableAns::_internal_songs(int index) const {
  return _impl_.songs_.Get(index);
}
inline const ::Song& TableAns::songs(int index) const {
  // @@protoc_insertion_point(field_get:TableAns.songs)
  return _internal_songs(index);
}
inline ::Song* TableAns::_internal_add_songs() {
  return _impl_.songs_.Add();
}
inline ::Song* TableAns::add_songs() {
  ::Song* _add = _internal_add_songs();
  // @@protoc_insertion_point(field_add:TableAns.songs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Song >&
TableAns::songs() const {
  // @@protoc_insertion_point(field_list:TableAns.songs)
  return _impl_.songs_;
}

// .EntityType type = 5;
inline void TableAns::clear_type() {
  _impl_.type_ = 0;
}
inline ::EntityType TableAns::_internal_type() const {
  return static_cast< ::EntityType >(_impl_.type_);
}
inline ::EntityType TableAns::type() const {
  // @@protoc_insertion_point(field_get:TableAns.type)
  return _internal_type();
}
inline void TableAns::_internal_set_type(::EntityType value) {
  
  _impl_.type_ = value;
}
inline void TableAns::set_type(::EntityType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TableAns.type)
}

// -------------------------------------------------------------------

// SimpleAns

// .Band band = 1;
inline bool SimpleAns::_internal_has_band() const {
  return msg_case() == kBand;
}
inline bool SimpleAns::has_band() const {
  return _internal_has_band();
}
inline void SimpleAns::set_has_band() {
  _impl_._oneof_case_[0] = kBand;
}
inline void SimpleAns::clear_band() {
  if (_internal_has_band()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.msg_.band_;
    }
    clear_has_msg();
  }
}
inline ::Band* SimpleAns::release_band() {
  // @@protoc_insertion_point(field_release:SimpleAns.band)
  if (_internal_has_band()) {
    clear_has_msg();
    ::Band* temp = _impl_.msg_.band_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.band_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Band& SimpleAns::_internal_band() const {
  return _internal_has_band()
      ? *_impl_.msg_.band_
      : reinterpret_cast< ::Band&>(::_Band_default_instance_);
}
inline const ::Band& SimpleAns::band() const {
  // @@protoc_insertion_point(field_get:SimpleAns.band)
  return _internal_band();
}
inline ::Band* SimpleAns::unsafe_arena_release_band() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SimpleAns.band)
  if (_internal_has_band()) {
    clear_has_msg();
    ::Band* temp = _impl_.msg_.band_;
    _impl_.msg_.band_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SimpleAns::unsafe_arena_set_allocated_band(::Band* band) {
  clear_msg();
  if (band) {
    set_has_band();
    _impl_.msg_.band_ = band;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SimpleAns.band)
}
inline ::Band* SimpleAns::_internal_mutable_band() {
  if (!_internal_has_band()) {
    clear_msg();
    set_has_band();
    _impl_.msg_.band_ = CreateMaybeMessage< ::Band >(GetArenaForAllocation());
  }
  return _impl_.msg_.band_;
}
inline ::Band* SimpleAns::mutable_band() {
  ::Band* _msg = _internal_mutable_band();
  // @@protoc_insertion_point(field_mutable:SimpleAns.band)
  return _msg;
}

// .Album album = 2;
inline bool SimpleAns::_internal_has_album() const {
  return msg_case() == kAlbum;
}
inline bool SimpleAns::has_album() const {
  return _internal_has_album();
}
inline void SimpleAns::set_has_album() {
  _impl_._oneof_case_[0] = kAlbum;
}
inline void SimpleAns::clear_album() {
  if (_internal_has_album()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.msg_.album_;
    }
    clear_has_msg();
  }
}
inline ::Album* SimpleAns::release_album() {
  // @@protoc_insertion_point(field_release:SimpleAns.album)
  if (_internal_has_album()) {
    clear_has_msg();
    ::Album* temp = _impl_.msg_.album_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.album_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Album& SimpleAns::_internal_album() const {
  return _internal_has_album()
      ? *_impl_.msg_.album_
      : reinterpret_cast< ::Album&>(::_Album_default_instance_);
}
inline const ::Album& SimpleAns::album() const {
  // @@protoc_insertion_point(field_get:SimpleAns.album)
  return _internal_album();
}
inline ::Album* SimpleAns::unsafe_arena_release_album() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SimpleAns.album)
  if (_internal_has_album()) {
    clear_has_msg();
    ::Album* temp = _impl_.msg_.album_;
    _impl_.msg_.album_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SimpleAns::unsafe_arena_set_allocated_album(::Album* album) {
  clear_msg();
  if (album) {
    set_has_album();
    _impl_.msg_.album_ = album;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SimpleAns.album)
}
inline ::Album* SimpleAns::_internal_mutable_album() {
  if (!_internal_has_album()) {
    clear_msg();
    set_has_album();
    _impl_.msg_.album_ = CreateMaybeMessage< ::Album >(GetArenaForAllocation());
  }
  return _impl_.msg_.album_;
}
inline ::Album* SimpleAns::mutable_album() {
  ::Album* _msg = _internal_mutable_album();
  // @@protoc_insertion_point(field_mutable:SimpleAns.album)
  return _msg;
}

// .Song song = 3;
inline bool SimpleAns::_internal_has_song() const {
  return msg_case() == kSong;
}
inline bool SimpleAns::has_song() const {
  return _internal_has_song();
}
inline void SimpleAns::set_has_song() {
  _impl_._oneof_case_[0] = kSong;
}
inline void SimpleAns::clear_song() {
  if (_internal_has_song()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.msg_.song_;
    }
    clear_has_msg();
  }
}
inline ::Song* SimpleAns::release_song() {
  // @@protoc_insertion_point(field_release:SimpleAns.song)
  if (_internal_has_song()) {
    clear_has_msg();
    ::Song* temp = _impl_.msg_.song_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.song_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Song& SimpleAns::_internal_song() const {
  return _internal_has_song()
      ? *_impl_.msg_.song_
      : reinterpret_cast< ::Song&>(::_Song_default_instance_);
}
inline const ::Song& SimpleAns::song() const {
  // @@protoc_insertion_point(field_get:SimpleAns.song)
  return _internal_song();
}
inline ::Song* SimpleAns::unsafe_arena_release_song() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SimpleAns.song)
  if (_internal_has_song()) {
    clear_has_msg();
    ::Song* temp = _impl_.msg_.song_;
    _impl_.msg_.song_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SimpleAns::unsafe_arena_set_allocated_song(::Song* song) {
  clear_msg();
  if (song) {
    set_has_song();
    _impl_.msg_.song_ = song;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SimpleAns.song)
}
inline ::Song* SimpleAns::_internal_mutable_song() {
  if (!_internal_has_song()) {
    clear_msg();
    set_has_song();
    _impl_.msg_.song_ = CreateMaybeMessage< ::Song >(GetArenaForAllocation());
  }
  return _impl_.msg_.song_;
}
inline ::Song* SimpleAns::mutable_song() {
  ::Song* _msg = _internal_mutable_song();
  // @@protoc_insertion_point(field_mutable:SimpleAns.song)
  return _msg;
}

// .Concert concert = 4;
inline bool SimpleAns::_internal_has_concert() const {
  return msg_case() == kConcert;
}
inline bool SimpleAns::has_concert() const {
  return _internal_has_concert();
}
inline void SimpleAns::set_has_concert() {
  _impl_._oneof_case_[0] = kConcert;
}
inline void SimpleAns::clear_concert() {
  if (_internal_has_concert()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.msg_.concert_;
    }
    clear_has_msg();
  }
}
inline ::Concert* SimpleAns::release_concert() {
  // @@protoc_insertion_point(field_release:SimpleAns.concert)
  if (_internal_has_concert()) {
    clear_has_msg();
    ::Concert* temp = _impl_.msg_.concert_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.concert_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Concert& SimpleAns::_internal_concert() const {
  return _internal_has_concert()
      ? *_impl_.msg_.concert_
      : reinterpret_cast< ::Concert&>(::_Concert_default_instance_);
}
inline const ::Concert& SimpleAns::concert() const {
  // @@protoc_insertion_point(field_get:SimpleAns.concert)
  return _internal_concert();
}
inline ::Concert* SimpleAns::unsafe_arena_release_concert() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SimpleAns.concert)
  if (_internal_has_concert()) {
    clear_has_msg();
    ::Concert* temp = _impl_.msg_.concert_;
    _impl_.msg_.concert_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SimpleAns::unsafe_arena_set_allocated_concert(::Concert* concert) {
  clear_msg();
  if (concert) {
    set_has_concert();
    _impl_.msg_.concert_ = concert;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SimpleAns.concert)
}
inline ::Concert* SimpleAns::_internal_mutable_concert() {
  if (!_internal_has_concert()) {
    clear_msg();
    set_has_concert();
    _impl_.msg_.concert_ = CreateMaybeMessage< ::Concert >(GetArenaForAllocation());
  }
  return _impl_.msg_.concert_;
}
inline ::Concert* SimpleAns::mutable_concert() {
  ::Concert* _msg = _internal_mutable_concert();
  // @@protoc_insertion_point(field_mutable:SimpleAns.concert)
  return _msg;
}

// .Musician musician = 5;
inline bool SimpleAns::_internal_has_musician() const {
  return msg_case() == kMusician;
}
inline bool SimpleAns::has_musician() const {
  return _internal_has_musician();
}
inline void SimpleAns::set_has_musician() {
  _impl_._oneof_case_[0] = kMusician;
}
inline void SimpleAns::clear_musician() {
  if (_internal_has_musician()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.msg_.musician_;
    }
    clear_has_msg();
  }
}
inline ::Musician* SimpleAns::release_musician() {
  // @@protoc_insertion_point(field_release:SimpleAns.musician)
  if (_internal_has_musician()) {
    clear_has_msg();
    ::Musician* temp = _impl_.msg_.musician_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.musician_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Musician& SimpleAns::_internal_musician() const {
  return _internal_has_musician()
      ? *_impl_.msg_.musician_
      : reinterpret_cast< ::Musician&>(::_Musician_default_instance_);
}
inline const ::Musician& SimpleAns::musician() const {
  // @@protoc_insertion_point(field_get:SimpleAns.musician)
  return _internal_musician();
}
inline ::Musician* SimpleAns::unsafe_arena_release_musician() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SimpleAns.musician)
  if (_internal_has_musician()) {
    clear_has_msg();
    ::Musician* temp = _impl_.msg_.musician_;
    _impl_.msg_.musician_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SimpleAns::unsafe_arena_set_allocated_musician(::Musician* musician) {
  clear_msg();
  if (musician) {
    set_has_musician();
    _impl_.msg_.musician_ = musician;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SimpleAns.musician)
}
inline ::Musician* SimpleAns::_internal_mutable_musician() {
  if (!_internal_has_musician()) {
    clear_msg();
    set_has_musician();
    _impl_.msg_.musician_ = CreateMaybeMessage< ::Musician >(GetArenaForAllocation());
  }
  return _impl_.msg_.musician_;
}
inline ::Musician* SimpleAns::mutable_musician() {
  ::Musician* _msg = _internal_mutable_musician();
  // @@protoc_insertion_point(field_mutable:SimpleAns.musician)
  return _msg;
}

// .Membership membership = 6;
inline bool SimpleAns::_internal_has_membership() const {
  return msg_case() == kMembership;
}
inline bool SimpleAns::has_membership() const {
  return _internal_has_membership();
}
inline void SimpleAns::set_has_membership() {
  _impl_._oneof_case_[0] = kMembership;
}
inline void SimpleAns::clear_membership() {
  if (_internal_has_membership()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.msg_.membership_;
    }
    clear_has_msg();
  }
}
inline ::Membership* SimpleAns::release_membership() {
  // @@protoc_insertion_point(field_release:SimpleAns.membership)
  if (_internal_has_membership()) {
    clear_has_msg();
    ::Membership* temp = _impl_.msg_.membership_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.membership_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Membership& SimpleAns::_internal_membership() const {
  return _internal_has_membership()
      ? *_impl_.msg_.membership_
      : reinterpret_cast< ::Membership&>(::_Membership_default_instance_);
}
inline const ::Membership& SimpleAns::membership() const {
  // @@protoc_insertion_point(field_get:SimpleAns.membership)
  return _internal_membership();
}
inline ::Membership* SimpleAns::unsafe_arena_release_membership() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SimpleAns.membership)
  if (_internal_has_membership()) {
    clear_has_msg();
    ::Membership* temp = _impl_.msg_.membership_;
    _impl_.msg_.membership_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SimpleAns::unsafe_arena_set_allocated_membership(::Membership* membership) {
  clear_msg();
  if (membership) {
    set_has_membership();
    _impl_.msg_.membership_ = membership;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SimpleAns.membership)
}
inline ::Membership* SimpleAns::_internal_mutable_membership() {
  if (!_internal_has_membership()) {
    clear_msg();
    set_has_membership();
    _impl_.msg_.membership_ = CreateMaybeMessage< ::Membership >(GetArenaForAllocation());
  }
  return _impl_.msg_.membership_;
}
inline ::Membership* SimpleAns::mutable_membership() {
  ::Membership* _msg = _internal_mutable_membership();
  // @@protoc_insertion_point(field_mutable:SimpleAns.membership)
  return _msg;
}

inline bool SimpleAns::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void SimpleAns::clear_has_msg() {
  _impl_._oneof_case_[0] = MSG_NOT_SET;
}
inline SimpleAns::MsgCase SimpleAns::msg_case() const {
  return SimpleAns::MsgCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// StreamAns

// bytes data = 1;
inline void StreamAns::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& StreamAns::data() const {
  // @@protoc_insertion_point(field_get:StreamAns.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamAns::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StreamAns.data)
}
inline std::string* StreamAns::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:StreamAns.data)
  return _s;
}
inline const std::string& StreamAns::_internal_data() const {
  return _impl_.data_.Get();
}
inline void StreamAns::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamAns::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamAns::release_data() {
  // @@protoc_insertion_point(field_release:StreamAns.data)
  return _impl_.data_.Release();
}
inline void StreamAns::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StreamAns.data)
}

// bool isFinal = 2;
inline void StreamAns::clear_isfinal() {
  _impl_.isfinal_ = false;
}
inline bool StreamAns::_internal_isfinal() const {
  return _impl_.isfinal_;
}
inline bool StreamAns::isfinal() const {
  // @@protoc_insertion_point(field_get:StreamAns.isFinal)
  return _internal_isfinal();
}
inline void StreamAns::_internal_set_isfinal(bool value) {
  
  _impl_.isfinal_ = value;
}
inline void StreamAns::set_isfinal(bool value) {
  _internal_set_isfinal(value);
  // @@protoc_insertion_point(field_set:StreamAns.isFinal)
}

// -------------------------------------------------------------------

// Membership

// string musName = 1;
inline void Membership::clear_musname() {
  _impl_.musname_.ClearToEmpty();
}
inline const std::string& Membership::musname() const {
  // @@protoc_insertion_point(field_get:Membership.musName)
  return _internal_musname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Membership::set_musname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.musname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Membership.musName)
}
inline std::string* Membership::mutable_musname() {
  std::string* _s = _internal_mutable_musname();
  // @@protoc_insertion_point(field_mutable:Membership.musName)
  return _s;
}
inline const std::string& Membership::_internal_musname() const {
  return _impl_.musname_.Get();
}
inline void Membership::_internal_set_musname(const std::string& value) {
  
  _impl_.musname_.Set(value, GetArenaForAllocation());
}
inline std::string* Membership::_internal_mutable_musname() {
  
  return _impl_.musname_.Mutable(GetArenaForAllocation());
}
inline std::string* Membership::release_musname() {
  // @@protoc_insertion_point(field_release:Membership.musName)
  return _impl_.musname_.Release();
}
inline void Membership::set_allocated_musname(std::string* musname) {
  if (musname != nullptr) {
    
  } else {
    
  }
  _impl_.musname_.SetAllocated(musname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.musname_.IsDefault()) {
    _impl_.musname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Membership.musName)
}

// string bandName = 2;
inline void Membership::clear_bandname() {
  _impl_.bandname_.ClearToEmpty();
}
inline const std::string& Membership::bandname() const {
  // @@protoc_insertion_point(field_get:Membership.bandName)
  return _internal_bandname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Membership::set_bandname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bandname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Membership.bandName)
}
inline std::string* Membership::mutable_bandname() {
  std::string* _s = _internal_mutable_bandname();
  // @@protoc_insertion_point(field_mutable:Membership.bandName)
  return _s;
}
inline const std::string& Membership::_internal_bandname() const {
  return _impl_.bandname_.Get();
}
inline void Membership::_internal_set_bandname(const std::string& value) {
  
  _impl_.bandname_.Set(value, GetArenaForAllocation());
}
inline std::string* Membership::_internal_mutable_bandname() {
  
  return _impl_.bandname_.Mutable(GetArenaForAllocation());
}
inline std::string* Membership::release_bandname() {
  // @@protoc_insertion_point(field_release:Membership.bandName)
  return _impl_.bandname_.Release();
}
inline void Membership::set_allocated_bandname(std::string* bandname) {
  if (bandname != nullptr) {
    
  } else {
    
  }
  _impl_.bandname_.SetAllocated(bandname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bandname_.IsDefault()) {
    _impl_.bandname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Membership.bandName)
}

// int64 unixEntryDate = 3;
inline void Membership::clear_unixentrydate() {
  _impl_.unixentrydate_ = int64_t{0};
}
inline int64_t Membership::_internal_unixentrydate() const {
  return _impl_.unixentrydate_;
}
inline int64_t Membership::unixentrydate() const {
  // @@protoc_insertion_point(field_get:Membership.unixEntryDate)
  return _internal_unixentrydate();
}
inline void Membership::_internal_set_unixentrydate(int64_t value) {
  
  _impl_.unixentrydate_ = value;
}
inline void Membership::set_unixentrydate(int64_t value) {
  _internal_set_unixentrydate(value);
  // @@protoc_insertion_point(field_set:Membership.unixEntryDate)
}

// int64 unixQuitDate = 4;
inline void Membership::clear_unixquitdate() {
  _impl_.unixquitdate_ = int64_t{0};
}
inline int64_t Membership::_internal_unixquitdate() const {
  return _impl_.unixquitdate_;
}
inline int64_t Membership::unixquitdate() const {
  // @@protoc_insertion_point(field_get:Membership.unixQuitDate)
  return _internal_unixquitdate();
}
inline void Membership::_internal_set_unixquitdate(int64_t value) {
  
  _impl_.unixquitdate_ = value;
}
inline void Membership::set_unixquitdate(int64_t value) {
  _internal_set_unixquitdate(value);
  // @@protoc_insertion_point(field_set:Membership.unixQuitDate)
}

// -------------------------------------------------------------------

// Concert

// int32 capacity = 1;
inline void Concert::clear_capacity() {
  _impl_.capacity_ = 0;
}
inline int32_t Concert::_internal_capacity() const {
  return _impl_.capacity_;
}
inline int32_t Concert::capacity() const {
  // @@protoc_insertion_point(field_get:Concert.capacity)
  return _internal_capacity();
}
inline void Concert::_internal_set_capacity(int32_t value) {
  
  _impl_.capacity_ = value;
}
inline void Concert::set_capacity(int32_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:Concert.capacity)
}

// string description = 2;
inline void Concert::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Concert::description() const {
  // @@protoc_insertion_point(field_get:Concert.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Concert::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Concert.description)
}
inline std::string* Concert::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:Concert.description)
  return _s;
}
inline const std::string& Concert::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Concert::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Concert::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Concert::release_description() {
  // @@protoc_insertion_point(field_release:Concert.description)
  return _impl_.description_.Release();
}
inline void Concert::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Concert.description)
}

// int64 unixDateTime = 3;
inline void Concert::clear_unixdatetime() {
  _impl_.unixdatetime_ = int64_t{0};
}
inline int64_t Concert::_internal_unixdatetime() const {
  return _impl_.unixdatetime_;
}
inline int64_t Concert::unixdatetime() const {
  // @@protoc_insertion_point(field_get:Concert.unixDateTime)
  return _internal_unixdatetime();
}
inline void Concert::_internal_set_unixdatetime(int64_t value) {
  
  _impl_.unixdatetime_ = value;
}
inline void Concert::set_unixdatetime(int64_t value) {
  _internal_set_unixdatetime(value);
  // @@protoc_insertion_point(field_set:Concert.unixDateTime)
}

// string location = 4;
inline void Concert::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& Concert::location() const {
  // @@protoc_insertion_point(field_get:Concert.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Concert::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Concert.location)
}
inline std::string* Concert::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:Concert.location)
  return _s;
}
inline const std::string& Concert::_internal_location() const {
  return _impl_.location_.Get();
}
inline void Concert::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* Concert::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* Concert::release_location() {
  // @@protoc_insertion_point(field_release:Concert.location)
  return _impl_.location_.Release();
}
inline void Concert::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Concert.location)
}

// repeated string bandNames = 5;
inline int Concert::_internal_bandnames_size() const {
  return _impl_.bandnames_.size();
}
inline int Concert::bandnames_size() const {
  return _internal_bandnames_size();
}
inline void Concert::clear_bandnames() {
  _impl_.bandnames_.Clear();
}
inline std::string* Concert::add_bandnames() {
  std::string* _s = _internal_add_bandnames();
  // @@protoc_insertion_point(field_add_mutable:Concert.bandNames)
  return _s;
}
inline const std::string& Concert::_internal_bandnames(int index) const {
  return _impl_.bandnames_.Get(index);
}
inline const std::string& Concert::bandnames(int index) const {
  // @@protoc_insertion_point(field_get:Concert.bandNames)
  return _internal_bandnames(index);
}
inline std::string* Concert::mutable_bandnames(int index) {
  // @@protoc_insertion_point(field_mutable:Concert.bandNames)
  return _impl_.bandnames_.Mutable(index);
}
inline void Concert::set_bandnames(int index, const std::string& value) {
  _impl_.bandnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Concert.bandNames)
}
inline void Concert::set_bandnames(int index, std::string&& value) {
  _impl_.bandnames_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Concert.bandNames)
}
inline void Concert::set_bandnames(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bandnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Concert.bandNames)
}
inline void Concert::set_bandnames(int index, const char* value, size_t size) {
  _impl_.bandnames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Concert.bandNames)
}
inline std::string* Concert::_internal_add_bandnames() {
  return _impl_.bandnames_.Add();
}
inline void Concert::add_bandnames(const std::string& value) {
  _impl_.bandnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Concert.bandNames)
}
inline void Concert::add_bandnames(std::string&& value) {
  _impl_.bandnames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Concert.bandNames)
}
inline void Concert::add_bandnames(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bandnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Concert.bandNames)
}
inline void Concert::add_bandnames(const char* value, size_t size) {
  _impl_.bandnames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Concert.bandNames)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Concert::bandnames() const {
  // @@protoc_insertion_point(field_list:Concert.bandNames)
  return _impl_.bandnames_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Concert::mutable_bandnames() {
  // @@protoc_insertion_point(field_mutable_list:Concert.bandNames)
  return &_impl_.bandnames_;
}

// -------------------------------------------------------------------

// Band

// string bandName = 1;
inline void Band::clear_bandname() {
  _impl_.bandname_.ClearToEmpty();
}
inline const std::string& Band::bandname() const {
  // @@protoc_insertion_point(field_get:Band.bandName)
  return _internal_bandname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Band::set_bandname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bandname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Band.bandName)
}
inline std::string* Band::mutable_bandname() {
  std::string* _s = _internal_mutable_bandname();
  // @@protoc_insertion_point(field_mutable:Band.bandName)
  return _s;
}
inline const std::string& Band::_internal_bandname() const {
  return _impl_.bandname_.Get();
}
inline void Band::_internal_set_bandname(const std::string& value) {
  
  _impl_.bandname_.Set(value, GetArenaForAllocation());
}
inline std::string* Band::_internal_mutable_bandname() {
  
  return _impl_.bandname_.Mutable(GetArenaForAllocation());
}
inline std::string* Band::release_bandname() {
  // @@protoc_insertion_point(field_release:Band.bandName)
  return _impl_.bandname_.Release();
}
inline void Band::set_allocated_bandname(std::string* bandname) {
  if (bandname != nullptr) {
    
  } else {
    
  }
  _impl_.bandname_.SetAllocated(bandname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bandname_.IsDefault()) {
    _impl_.bandname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Band.bandName)
}

// .Genre genre = 2;
inline void Band::clear_genre() {
  _impl_.genre_ = 0;
}
inline ::Genre Band::_internal_genre() const {
  return static_cast< ::Genre >(_impl_.genre_);
}
inline ::Genre Band::genre() const {
  // @@protoc_insertion_point(field_get:Band.genre)
  return _internal_genre();
}
inline void Band::_internal_set_genre(::Genre value) {
  
  _impl_.genre_ = value;
}
inline void Band::set_genre(::Genre value) {
  _internal_set_genre(value);
  // @@protoc_insertion_point(field_set:Band.genre)
}

// int64 unixFoundDate = 3;
inline void Band::clear_unixfounddate() {
  _impl_.unixfounddate_ = int64_t{0};
}
inline int64_t Band::_internal_unixfounddate() const {
  return _impl_.unixfounddate_;
}
inline int64_t Band::unixfounddate() const {
  // @@protoc_insertion_point(field_get:Band.unixFoundDate)
  return _internal_unixfounddate();
}
inline void Band::_internal_set_unixfounddate(int64_t value) {
  
  _impl_.unixfounddate_ = value;
}
inline void Band::set_unixfounddate(int64_t value) {
  _internal_set_unixfounddate(value);
  // @@protoc_insertion_point(field_set:Band.unixFoundDate)
}

// int64 unixTermDate = 4;
inline void Band::clear_unixtermdate() {
  _impl_.unixtermdate_ = int64_t{0};
}
inline int64_t Band::_internal_unixtermdate() const {
  return _impl_.unixtermdate_;
}
inline int64_t Band::unixtermdate() const {
  // @@protoc_insertion_point(field_get:Band.unixTermDate)
  return _internal_unixtermdate();
}
inline void Band::_internal_set_unixtermdate(int64_t value) {
  
  _impl_.unixtermdate_ = value;
}
inline void Band::set_unixtermdate(int64_t value) {
  _internal_set_unixtermdate(value);
  // @@protoc_insertion_point(field_set:Band.unixTermDate)
}

// string description = 5;
inline void Band::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Band::description() const {
  // @@protoc_insertion_point(field_get:Band.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Band::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Band.description)
}
inline std::string* Band::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:Band.description)
  return _s;
}
inline const std::string& Band::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Band::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Band::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Band::release_description() {
  // @@protoc_insertion_point(field_release:Band.description)
  return _impl_.description_.Release();
}
inline void Band::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Band.description)
}

// int64 objId = 9;
inline void Band::clear_objid() {
  _impl_.objid_ = int64_t{0};
}
inline int64_t Band::_internal_objid() const {
  return _impl_.objid_;
}
inline int64_t Band::objid() const {
  // @@protoc_insertion_point(field_get:Band.objId)
  return _internal_objid();
}
inline void Band::_internal_set_objid(int64_t value) {
  
  _impl_.objid_ = value;
}
inline void Band::set_objid(int64_t value) {
  _internal_set_objid(value);
  // @@protoc_insertion_point(field_set:Band.objId)
}

// repeated string albumNames = 6;
inline int Band::_internal_albumnames_size() const {
  return _impl_.albumnames_.size();
}
inline int Band::albumnames_size() const {
  return _internal_albumnames_size();
}
inline void Band::clear_albumnames() {
  _impl_.albumnames_.Clear();
}
inline std::string* Band::add_albumnames() {
  std::string* _s = _internal_add_albumnames();
  // @@protoc_insertion_point(field_add_mutable:Band.albumNames)
  return _s;
}
inline const std::string& Band::_internal_albumnames(int index) const {
  return _impl_.albumnames_.Get(index);
}
inline const std::string& Band::albumnames(int index) const {
  // @@protoc_insertion_point(field_get:Band.albumNames)
  return _internal_albumnames(index);
}
inline std::string* Band::mutable_albumnames(int index) {
  // @@protoc_insertion_point(field_mutable:Band.albumNames)
  return _impl_.albumnames_.Mutable(index);
}
inline void Band::set_albumnames(int index, const std::string& value) {
  _impl_.albumnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Band.albumNames)
}
inline void Band::set_albumnames(int index, std::string&& value) {
  _impl_.albumnames_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Band.albumNames)
}
inline void Band::set_albumnames(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.albumnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Band.albumNames)
}
inline void Band::set_albumnames(int index, const char* value, size_t size) {
  _impl_.albumnames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Band.albumNames)
}
inline std::string* Band::_internal_add_albumnames() {
  return _impl_.albumnames_.Add();
}
inline void Band::add_albumnames(const std::string& value) {
  _impl_.albumnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Band.albumNames)
}
inline void Band::add_albumnames(std::string&& value) {
  _impl_.albumnames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Band.albumNames)
}
inline void Band::add_albumnames(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.albumnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Band.albumNames)
}
inline void Band::add_albumnames(const char* value, size_t size) {
  _impl_.albumnames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Band.albumNames)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Band::albumnames() const {
  // @@protoc_insertion_point(field_list:Band.albumNames)
  return _impl_.albumnames_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Band::mutable_albumnames() {
  // @@protoc_insertion_point(field_mutable_list:Band.albumNames)
  return &_impl_.albumnames_;
}

// repeated .Membership participants = 7;
inline int Band::_internal_participants_size() const {
  return _impl_.participants_.size();
}
inline int Band::participants_size() const {
  return _internal_participants_size();
}
inline void Band::clear_participants() {
  _impl_.participants_.Clear();
}
inline ::Membership* Band::mutable_participants(int index) {
  // @@protoc_insertion_point(field_mutable:Band.participants)
  return _impl_.participants_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Membership >*
Band::mutable_participants() {
  // @@protoc_insertion_point(field_mutable_list:Band.participants)
  return &_impl_.participants_;
}
inline const ::Membership& Band::_internal_participants(int index) const {
  return _impl_.participants_.Get(index);
}
inline const ::Membership& Band::participants(int index) const {
  // @@protoc_insertion_point(field_get:Band.participants)
  return _internal_participants(index);
}
inline ::Membership* Band::_internal_add_participants() {
  return _impl_.participants_.Add();
}
inline ::Membership* Band::add_participants() {
  ::Membership* _add = _internal_add_participants();
  // @@protoc_insertion_point(field_add:Band.participants)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Membership >&
Band::participants() const {
  // @@protoc_insertion_point(field_list:Band.participants)
  return _impl_.participants_;
}

// repeated .Concert concerts = 8;
inline int Band::_internal_concerts_size() const {
  return _impl_.concerts_.size();
}
inline int Band::concerts_size() const {
  return _internal_concerts_size();
}
inline void Band::clear_concerts() {
  _impl_.concerts_.Clear();
}
inline ::Concert* Band::mutable_concerts(int index) {
  // @@protoc_insertion_point(field_mutable:Band.concerts)
  return _impl_.concerts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Concert >*
Band::mutable_concerts() {
  // @@protoc_insertion_point(field_mutable_list:Band.concerts)
  return &_impl_.concerts_;
}
inline const ::Concert& Band::_internal_concerts(int index) const {
  return _impl_.concerts_.Get(index);
}
inline const ::Concert& Band::concerts(int index) const {
  // @@protoc_insertion_point(field_get:Band.concerts)
  return _internal_concerts(index);
}
inline ::Concert* Band::_internal_add_concerts() {
  return _impl_.concerts_.Add();
}
inline ::Concert* Band::add_concerts() {
  ::Concert* _add = _internal_add_concerts();
  // @@protoc_insertion_point(field_add:Band.concerts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Concert >&
Band::concerts() const {
  // @@protoc_insertion_point(field_list:Band.concerts)
  return _impl_.concerts_;
}

// -------------------------------------------------------------------

// Song

// string songName = 1;
inline void Song::clear_songname() {
  _impl_.songname_.ClearToEmpty();
}
inline const std::string& Song::songname() const {
  // @@protoc_insertion_point(field_get:Song.songName)
  return _internal_songname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Song::set_songname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.songname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Song.songName)
}
inline std::string* Song::mutable_songname() {
  std::string* _s = _internal_mutable_songname();
  // @@protoc_insertion_point(field_mutable:Song.songName)
  return _s;
}
inline const std::string& Song::_internal_songname() const {
  return _impl_.songname_.Get();
}
inline void Song::_internal_set_songname(const std::string& value) {
  
  _impl_.songname_.Set(value, GetArenaForAllocation());
}
inline std::string* Song::_internal_mutable_songname() {
  
  return _impl_.songname_.Mutable(GetArenaForAllocation());
}
inline std::string* Song::release_songname() {
  // @@protoc_insertion_point(field_release:Song.songName)
  return _impl_.songname_.Release();
}
inline void Song::set_allocated_songname(std::string* songname) {
  if (songname != nullptr) {
    
  } else {
    
  }
  _impl_.songname_.SetAllocated(songname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.songname_.IsDefault()) {
    _impl_.songname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Song.songName)
}

// int32 lengthSec = 2;
inline void Song::clear_lengthsec() {
  _impl_.lengthsec_ = 0;
}
inline int32_t Song::_internal_lengthsec() const {
  return _impl_.lengthsec_;
}
inline int32_t Song::lengthsec() const {
  // @@protoc_insertion_point(field_get:Song.lengthSec)
  return _internal_lengthsec();
}
inline void Song::_internal_set_lengthsec(int32_t value) {
  
  _impl_.lengthsec_ = value;
}
inline void Song::set_lengthsec(int32_t value) {
  _internal_set_lengthsec(value);
  // @@protoc_insertion_point(field_set:Song.lengthSec)
}

// string albumName = 3;
inline void Song::clear_albumname() {
  _impl_.albumname_.ClearToEmpty();
}
inline const std::string& Song::albumname() const {
  // @@protoc_insertion_point(field_get:Song.albumName)
  return _internal_albumname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Song::set_albumname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.albumname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Song.albumName)
}
inline std::string* Song::mutable_albumname() {
  std::string* _s = _internal_mutable_albumname();
  // @@protoc_insertion_point(field_mutable:Song.albumName)
  return _s;
}
inline const std::string& Song::_internal_albumname() const {
  return _impl_.albumname_.Get();
}
inline void Song::_internal_set_albumname(const std::string& value) {
  
  _impl_.albumname_.Set(value, GetArenaForAllocation());
}
inline std::string* Song::_internal_mutable_albumname() {
  
  return _impl_.albumname_.Mutable(GetArenaForAllocation());
}
inline std::string* Song::release_albumname() {
  // @@protoc_insertion_point(field_release:Song.albumName)
  return _impl_.albumname_.Release();
}
inline void Song::set_allocated_albumname(std::string* albumname) {
  if (albumname != nullptr) {
    
  } else {
    
  }
  _impl_.albumname_.SetAllocated(albumname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.albumname_.IsDefault()) {
    _impl_.albumname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Song.albumName)
}

// string bandName = 4;
inline void Song::clear_bandname() {
  _impl_.bandname_.ClearToEmpty();
}
inline const std::string& Song::bandname() const {
  // @@protoc_insertion_point(field_get:Song.bandName)
  return _internal_bandname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Song::set_bandname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bandname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Song.bandName)
}
inline std::string* Song::mutable_bandname() {
  std::string* _s = _internal_mutable_bandname();
  // @@protoc_insertion_point(field_mutable:Song.bandName)
  return _s;
}
inline const std::string& Song::_internal_bandname() const {
  return _impl_.bandname_.Get();
}
inline void Song::_internal_set_bandname(const std::string& value) {
  
  _impl_.bandname_.Set(value, GetArenaForAllocation());
}
inline std::string* Song::_internal_mutable_bandname() {
  
  return _impl_.bandname_.Mutable(GetArenaForAllocation());
}
inline std::string* Song::release_bandname() {
  // @@protoc_insertion_point(field_release:Song.bandName)
  return _impl_.bandname_.Release();
}
inline void Song::set_allocated_bandname(std::string* bandname) {
  if (bandname != nullptr) {
    
  } else {
    
  }
  _impl_.bandname_.SetAllocated(bandname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bandname_.IsDefault()) {
    _impl_.bandname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Song.bandName)
}

// int64 objId = 5;
inline void Song::clear_objid() {
  _impl_.objid_ = int64_t{0};
}
inline int64_t Song::_internal_objid() const {
  return _impl_.objid_;
}
inline int64_t Song::objid() const {
  // @@protoc_insertion_point(field_get:Song.objId)
  return _internal_objid();
}
inline void Song::_internal_set_objid(int64_t value) {
  
  _impl_.objid_ = value;
}
inline void Song::set_objid(int64_t value) {
  _internal_set_objid(value);
  // @@protoc_insertion_point(field_set:Song.objId)
}

// -------------------------------------------------------------------

// Album

// string title = 1;
inline void Album::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& Album::title() const {
  // @@protoc_insertion_point(field_get:Album.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Album::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Album.title)
}
inline std::string* Album::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:Album.title)
  return _s;
}
inline const std::string& Album::_internal_title() const {
  return _impl_.title_.Get();
}
inline void Album::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* Album::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* Album::release_title() {
  // @@protoc_insertion_point(field_release:Album.title)
  return _impl_.title_.Release();
}
inline void Album::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Album.title)
}

// int64 unixReleaseDate = 2;
inline void Album::clear_unixreleasedate() {
  _impl_.unixreleasedate_ = int64_t{0};
}
inline int64_t Album::_internal_unixreleasedate() const {
  return _impl_.unixreleasedate_;
}
inline int64_t Album::unixreleasedate() const {
  // @@protoc_insertion_point(field_get:Album.unixReleaseDate)
  return _internal_unixreleasedate();
}
inline void Album::_internal_set_unixreleasedate(int64_t value) {
  
  _impl_.unixreleasedate_ = value;
}
inline void Album::set_unixreleasedate(int64_t value) {
  _internal_set_unixreleasedate(value);
  // @@protoc_insertion_point(field_set:Album.unixReleaseDate)
}

// repeated .Song songs = 3;
inline int Album::_internal_songs_size() const {
  return _impl_.songs_.size();
}
inline int Album::songs_size() const {
  return _internal_songs_size();
}
inline void Album::clear_songs() {
  _impl_.songs_.Clear();
}
inline ::Song* Album::mutable_songs(int index) {
  // @@protoc_insertion_point(field_mutable:Album.songs)
  return _impl_.songs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Song >*
Album::mutable_songs() {
  // @@protoc_insertion_point(field_mutable_list:Album.songs)
  return &_impl_.songs_;
}
inline const ::Song& Album::_internal_songs(int index) const {
  return _impl_.songs_.Get(index);
}
inline const ::Song& Album::songs(int index) const {
  // @@protoc_insertion_point(field_get:Album.songs)
  return _internal_songs(index);
}
inline ::Song* Album::_internal_add_songs() {
  return _impl_.songs_.Add();
}
inline ::Song* Album::add_songs() {
  ::Song* _add = _internal_add_songs();
  // @@protoc_insertion_point(field_add:Album.songs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Song >&
Album::songs() const {
  // @@protoc_insertion_point(field_list:Album.songs)
  return _impl_.songs_;
}

// string bandName = 4;
inline void Album::clear_bandname() {
  _impl_.bandname_.ClearToEmpty();
}
inline const std::string& Album::bandname() const {
  // @@protoc_insertion_point(field_get:Album.bandName)
  return _internal_bandname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Album::set_bandname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bandname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Album.bandName)
}
inline std::string* Album::mutable_bandname() {
  std::string* _s = _internal_mutable_bandname();
  // @@protoc_insertion_point(field_mutable:Album.bandName)
  return _s;
}
inline const std::string& Album::_internal_bandname() const {
  return _impl_.bandname_.Get();
}
inline void Album::_internal_set_bandname(const std::string& value) {
  
  _impl_.bandname_.Set(value, GetArenaForAllocation());
}
inline std::string* Album::_internal_mutable_bandname() {
  
  return _impl_.bandname_.Mutable(GetArenaForAllocation());
}
inline std::string* Album::release_bandname() {
  // @@protoc_insertion_point(field_release:Album.bandName)
  return _impl_.bandname_.Release();
}
inline void Album::set_allocated_bandname(std::string* bandname) {
  if (bandname != nullptr) {
    
  } else {
    
  }
  _impl_.bandname_.SetAllocated(bandname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bandname_.IsDefault()) {
    _impl_.bandname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Album.bandName)
}

// -------------------------------------------------------------------

// Musician

// string musName = 1;
inline void Musician::clear_musname() {
  _impl_.musname_.ClearToEmpty();
}
inline const std::string& Musician::musname() const {
  // @@protoc_insertion_point(field_get:Musician.musName)
  return _internal_musname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Musician::set_musname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.musname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Musician.musName)
}
inline std::string* Musician::mutable_musname() {
  std::string* _s = _internal_mutable_musname();
  // @@protoc_insertion_point(field_mutable:Musician.musName)
  return _s;
}
inline const std::string& Musician::_internal_musname() const {
  return _impl_.musname_.Get();
}
inline void Musician::_internal_set_musname(const std::string& value) {
  
  _impl_.musname_.Set(value, GetArenaForAllocation());
}
inline std::string* Musician::_internal_mutable_musname() {
  
  return _impl_.musname_.Mutable(GetArenaForAllocation());
}
inline std::string* Musician::release_musname() {
  // @@protoc_insertion_point(field_release:Musician.musName)
  return _impl_.musname_.Release();
}
inline void Musician::set_allocated_musname(std::string* musname) {
  if (musname != nullptr) {
    
  } else {
    
  }
  _impl_.musname_.SetAllocated(musname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.musname_.IsDefault()) {
    _impl_.musname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Musician.musName)
}

// int64 unixDateOfBirth = 2;
inline void Musician::clear_unixdateofbirth() {
  _impl_.unixdateofbirth_ = int64_t{0};
}
inline int64_t Musician::_internal_unixdateofbirth() const {
  return _impl_.unixdateofbirth_;
}
inline int64_t Musician::unixdateofbirth() const {
  // @@protoc_insertion_point(field_get:Musician.unixDateOfBirth)
  return _internal_unixdateofbirth();
}
inline void Musician::_internal_set_unixdateofbirth(int64_t value) {
  
  _impl_.unixdateofbirth_ = value;
}
inline void Musician::set_unixdateofbirth(int64_t value) {
  _internal_set_unixdateofbirth(value);
  // @@protoc_insertion_point(field_set:Musician.unixDateOfBirth)
}

// string bio = 3;
inline void Musician::clear_bio() {
  _impl_.bio_.ClearToEmpty();
}
inline const std::string& Musician::bio() const {
  // @@protoc_insertion_point(field_get:Musician.bio)
  return _internal_bio();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Musician::set_bio(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bio_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Musician.bio)
}
inline std::string* Musician::mutable_bio() {
  std::string* _s = _internal_mutable_bio();
  // @@protoc_insertion_point(field_mutable:Musician.bio)
  return _s;
}
inline const std::string& Musician::_internal_bio() const {
  return _impl_.bio_.Get();
}
inline void Musician::_internal_set_bio(const std::string& value) {
  
  _impl_.bio_.Set(value, GetArenaForAllocation());
}
inline std::string* Musician::_internal_mutable_bio() {
  
  return _impl_.bio_.Mutable(GetArenaForAllocation());
}
inline std::string* Musician::release_bio() {
  // @@protoc_insertion_point(field_release:Musician.bio)
  return _impl_.bio_.Release();
}
inline void Musician::set_allocated_bio(std::string* bio) {
  if (bio != nullptr) {
    
  } else {
    
  }
  _impl_.bio_.SetAllocated(bio, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bio_.IsDefault()) {
    _impl_.bio_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Musician.bio)
}

// int64 objId = 5;
inline void Musician::clear_objid() {
  _impl_.objid_ = int64_t{0};
}
inline int64_t Musician::_internal_objid() const {
  return _impl_.objid_;
}
inline int64_t Musician::objid() const {
  // @@protoc_insertion_point(field_get:Musician.objId)
  return _internal_objid();
}
inline void Musician::_internal_set_objid(int64_t value) {
  
  _impl_.objid_ = value;
}
inline void Musician::set_objid(int64_t value) {
  _internal_set_objid(value);
  // @@protoc_insertion_point(field_set:Musician.objId)
}

// repeated .Membership memberships = 4;
inline int Musician::_internal_memberships_size() const {
  return _impl_.memberships_.size();
}
inline int Musician::memberships_size() const {
  return _internal_memberships_size();
}
inline void Musician::clear_memberships() {
  _impl_.memberships_.Clear();
}
inline ::Membership* Musician::mutable_memberships(int index) {
  // @@protoc_insertion_point(field_mutable:Musician.memberships)
  return _impl_.memberships_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Membership >*
Musician::mutable_memberships() {
  // @@protoc_insertion_point(field_mutable_list:Musician.memberships)
  return &_impl_.memberships_;
}
inline const ::Membership& Musician::_internal_memberships(int index) const {
  return _impl_.memberships_.Get(index);
}
inline const ::Membership& Musician::memberships(int index) const {
  // @@protoc_insertion_point(field_get:Musician.memberships)
  return _internal_memberships(index);
}
inline ::Membership* Musician::_internal_add_memberships() {
  return _impl_.memberships_.Add();
}
inline ::Membership* Musician::add_memberships() {
  ::Membership* _add = _internal_add_memberships();
  // @@protoc_insertion_point(field_add:Musician.memberships)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Membership >&
Musician::memberships() const {
  // @@protoc_insertion_point(field_list:Musician.memberships)
  return _impl_.memberships_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::EntityType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EntityType>() {
  return ::EntityType_descriptor();
}
template <> struct is_proto_enum< ::Genre> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Genre>() {
  return ::Genre_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_messages_2eproto
