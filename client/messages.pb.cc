// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#include "messages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR Request::Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.reqid_)*/uint64_t{0u}
  , /*decltype(_impl_.cancel_)*/false
  , /*decltype(_impl_.msg_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestDefaultTypeInternal() {}
  union {
    Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestDefaultTypeInternal _Request_default_instance_;
PROTOBUF_CONSTEXPR Answer::Answer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.reqid_)*/uint64_t{0u}
  , /*decltype(_impl_.cancel_)*/false
  , /*decltype(_impl_.msg_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct AnswerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnswerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnswerDefaultTypeInternal() {}
  union {
    Answer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnswerDefaultTypeInternal _Answer_default_instance_;
PROTOBUF_CONSTEXPR TableReq::TableReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.filter_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.first_)*/0u
  , /*decltype(_impl_.last_)*/0u
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TableReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableReqDefaultTypeInternal() {}
  union {
    TableReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableReqDefaultTypeInternal _TableReq_default_instance_;
PROTOBUF_CONSTEXPR SimpleReq::SimpleReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.reqstring_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SimpleReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SimpleReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SimpleReqDefaultTypeInternal() {}
  union {
    SimpleReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SimpleReqDefaultTypeInternal _SimpleReq_default_instance_;
PROTOBUF_CONSTEXPR StreamReq::StreamReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.objid_)*/int64_t{0}
  , /*decltype(_impl_.suggestedsize_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamReqDefaultTypeInternal() {}
  union {
    StreamReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamReqDefaultTypeInternal _StreamReq_default_instance_;
PROTOBUF_CONSTEXPR TableAns::TableAns(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.bands_)*/{}
  , /*decltype(_impl_.albums_)*/{}
  , /*decltype(_impl_.concerts_)*/{}
  , /*decltype(_impl_.songs_)*/{}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TableAnsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableAnsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableAnsDefaultTypeInternal() {}
  union {
    TableAns _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableAnsDefaultTypeInternal _TableAns_default_instance_;
PROTOBUF_CONSTEXPR SimpleAns::SimpleAns(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.msg_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SimpleAnsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SimpleAnsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SimpleAnsDefaultTypeInternal() {}
  union {
    SimpleAns _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SimpleAnsDefaultTypeInternal _SimpleAns_default_instance_;
PROTOBUF_CONSTEXPR StreamAns::StreamAns(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.isfinal_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamAnsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamAnsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamAnsDefaultTypeInternal() {}
  union {
    StreamAns _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamAnsDefaultTypeInternal _StreamAns_default_instance_;
PROTOBUF_CONSTEXPR Membership::Membership(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.musname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bandname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.unixentrydate_)*/int64_t{0}
  , /*decltype(_impl_.unixquitdate_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MembershipDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MembershipDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MembershipDefaultTypeInternal() {}
  union {
    Membership _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MembershipDefaultTypeInternal _Membership_default_instance_;
PROTOBUF_CONSTEXPR Concert::Concert(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.bandnames_)*/{}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.location_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.unixdatetime_)*/int64_t{0}
  , /*decltype(_impl_.capacity_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConcertDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConcertDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConcertDefaultTypeInternal() {}
  union {
    Concert _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConcertDefaultTypeInternal _Concert_default_instance_;
PROTOBUF_CONSTEXPR Band::Band(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.albumnames_)*/{}
  , /*decltype(_impl_.participants_)*/{}
  , /*decltype(_impl_.concerts_)*/{}
  , /*decltype(_impl_.bandname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.unixfounddate_)*/int64_t{0}
  , /*decltype(_impl_.unixtermdate_)*/int64_t{0}
  , /*decltype(_impl_.objid_)*/int64_t{0}
  , /*decltype(_impl_.genre_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BandDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BandDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BandDefaultTypeInternal() {}
  union {
    Band _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandDefaultTypeInternal _Band_default_instance_;
PROTOBUF_CONSTEXPR Song::Song(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.songname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.albumname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bandname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.objid_)*/int64_t{0}
  , /*decltype(_impl_.lengthsec_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SongDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SongDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SongDefaultTypeInternal() {}
  union {
    Song _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SongDefaultTypeInternal _Song_default_instance_;
PROTOBUF_CONSTEXPR Album::Album(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.songs_)*/{}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bandname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.unixreleasedate_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AlbumDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AlbumDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AlbumDefaultTypeInternal() {}
  union {
    Album _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AlbumDefaultTypeInternal _Album_default_instance_;
PROTOBUF_CONSTEXPR Musician::Musician(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.memberships_)*/{}
  , /*decltype(_impl_.musname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bio_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.unixdateofbirth_)*/int64_t{0}
  , /*decltype(_impl_.objid_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MusicianDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MusicianDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MusicianDefaultTypeInternal() {}
  union {
    Musician _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MusicianDefaultTypeInternal _Musician_default_instance_;
static ::_pb::Metadata file_level_metadata_messages_2eproto[14];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_messages_2eproto[2];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_messages_2eproto = nullptr;

const uint32_t TableStruct_messages_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Request, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::Request, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Request, _impl_.reqid_),
  PROTOBUF_FIELD_OFFSET(::Request, _impl_.cancel_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::Request, _impl_.msg_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Answer, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::Answer, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Answer, _impl_.reqid_),
  PROTOBUF_FIELD_OFFSET(::Answer, _impl_.cancel_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::Answer, _impl_.msg_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TableReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TableReq, _impl_.first_),
  PROTOBUF_FIELD_OFFSET(::TableReq, _impl_.last_),
  PROTOBUF_FIELD_OFFSET(::TableReq, _impl_.filter_),
  PROTOBUF_FIELD_OFFSET(::TableReq, _impl_.type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SimpleReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SimpleReq, _impl_.reqstring_),
  PROTOBUF_FIELD_OFFSET(::SimpleReq, _impl_.type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::StreamReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StreamReq, _impl_.objid_),
  PROTOBUF_FIELD_OFFSET(::StreamReq, _impl_.suggestedsize_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TableAns, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TableAns, _impl_.bands_),
  PROTOBUF_FIELD_OFFSET(::TableAns, _impl_.albums_),
  PROTOBUF_FIELD_OFFSET(::TableAns, _impl_.concerts_),
  PROTOBUF_FIELD_OFFSET(::TableAns, _impl_.songs_),
  PROTOBUF_FIELD_OFFSET(::TableAns, _impl_.type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SimpleAns, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::SimpleAns, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::SimpleAns, _impl_.msg_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::StreamAns, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StreamAns, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::StreamAns, _impl_.isfinal_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Membership, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Membership, _impl_.musname_),
  PROTOBUF_FIELD_OFFSET(::Membership, _impl_.bandname_),
  PROTOBUF_FIELD_OFFSET(::Membership, _impl_.unixentrydate_),
  PROTOBUF_FIELD_OFFSET(::Membership, _impl_.unixquitdate_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Concert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Concert, _impl_.capacity_),
  PROTOBUF_FIELD_OFFSET(::Concert, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::Concert, _impl_.unixdatetime_),
  PROTOBUF_FIELD_OFFSET(::Concert, _impl_.location_),
  PROTOBUF_FIELD_OFFSET(::Concert, _impl_.bandnames_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Band, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Band, _impl_.bandname_),
  PROTOBUF_FIELD_OFFSET(::Band, _impl_.genre_),
  PROTOBUF_FIELD_OFFSET(::Band, _impl_.unixfounddate_),
  PROTOBUF_FIELD_OFFSET(::Band, _impl_.unixtermdate_),
  PROTOBUF_FIELD_OFFSET(::Band, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::Band, _impl_.objid_),
  PROTOBUF_FIELD_OFFSET(::Band, _impl_.albumnames_),
  PROTOBUF_FIELD_OFFSET(::Band, _impl_.participants_),
  PROTOBUF_FIELD_OFFSET(::Band, _impl_.concerts_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Song, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Song, _impl_.songname_),
  PROTOBUF_FIELD_OFFSET(::Song, _impl_.lengthsec_),
  PROTOBUF_FIELD_OFFSET(::Song, _impl_.albumname_),
  PROTOBUF_FIELD_OFFSET(::Song, _impl_.bandname_),
  PROTOBUF_FIELD_OFFSET(::Song, _impl_.objid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Album, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Album, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::Album, _impl_.unixreleasedate_),
  PROTOBUF_FIELD_OFFSET(::Album, _impl_.songs_),
  PROTOBUF_FIELD_OFFSET(::Album, _impl_.bandname_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Musician, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Musician, _impl_.musname_),
  PROTOBUF_FIELD_OFFSET(::Musician, _impl_.unixdateofbirth_),
  PROTOBUF_FIELD_OFFSET(::Musician, _impl_.bio_),
  PROTOBUF_FIELD_OFFSET(::Musician, _impl_.objid_),
  PROTOBUF_FIELD_OFFSET(::Musician, _impl_.memberships_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::Request)},
  { 12, -1, -1, sizeof(::Answer)},
  { 24, -1, -1, sizeof(::TableReq)},
  { 34, -1, -1, sizeof(::SimpleReq)},
  { 42, -1, -1, sizeof(::StreamReq)},
  { 50, -1, -1, sizeof(::TableAns)},
  { 61, -1, -1, sizeof(::SimpleAns)},
  { 74, -1, -1, sizeof(::StreamAns)},
  { 82, -1, -1, sizeof(::Membership)},
  { 92, -1, -1, sizeof(::Concert)},
  { 103, -1, -1, sizeof(::Band)},
  { 118, -1, -1, sizeof(::Song)},
  { 129, -1, -1, sizeof(::Album)},
  { 139, -1, -1, sizeof(::Musician)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_Request_default_instance_._instance,
  &::_Answer_default_instance_._instance,
  &::_TableReq_default_instance_._instance,
  &::_SimpleReq_default_instance_._instance,
  &::_StreamReq_default_instance_._instance,
  &::_TableAns_default_instance_._instance,
  &::_SimpleAns_default_instance_._instance,
  &::_StreamAns_default_instance_._instance,
  &::_Membership_default_instance_._instance,
  &::_Concert_default_instance_._instance,
  &::_Band_default_instance_._instance,
  &::_Song_default_instance_._instance,
  &::_Album_default_instance_._instance,
  &::_Musician_default_instance_._instance,
};

const char descriptor_table_protodef_messages_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016messages.proto\"\220\001\n\007Request\022\r\n\005reqId\030\001 "
  "\001(\004\022\016\n\006cancel\030\003 \001(\010\022\035\n\010tableReq\030\004 \001(\0132\t."
  "TableReqH\000\022\037\n\tsimpleReq\030\005 \001(\0132\n.SimpleRe"
  "qH\000\022\037\n\tstreamReq\030\006 \001(\0132\n.StreamReqH\000B\005\n\003"
  "msg\"\217\001\n\006Answer\022\r\n\005reqId\030\001 \001(\004\022\016\n\006cancel\030"
  "\002 \001(\010\022\035\n\010tableAns\030\003 \001(\0132\t.TableAnsH\000\022\037\n\t"
  "simpleAns\030\004 \001(\0132\n.SimpleAnsH\000\022\037\n\tstreamA"
  "ns\030\005 \001(\0132\n.StreamAnsH\000B\005\n\003msg\"R\n\010TableRe"
  "q\022\r\n\005first\030\001 \001(\r\022\014\n\004last\030\002 \001(\r\022\016\n\006filter"
  "\030\003 \001(\t\022\031\n\004type\030\004 \001(\0162\013.EntityType\"9\n\tSim"
  "pleReq\022\021\n\treqString\030\001 \001(\t\022\031\n\004type\030\004 \001(\0162"
  "\013.EntityType\"1\n\tStreamReq\022\r\n\005objId\030\001 \001(\003"
  "\022\025\n\rsuggestedSize\030\002 \001(\005\"\205\001\n\010TableAns\022\024\n\005"
  "bands\030\001 \003(\0132\005.Band\022\026\n\006albums\030\002 \003(\0132\006.Alb"
  "um\022\032\n\010concerts\030\003 \003(\0132\010.Concert\022\024\n\005songs\030"
  "\004 \003(\0132\005.Song\022\031\n\004type\030\005 \001(\0162\013.EntityType\""
  "\270\001\n\tSimpleAns\022\025\n\004band\030\001 \001(\0132\005.BandH\000\022\027\n\005"
  "album\030\002 \001(\0132\006.AlbumH\000\022\025\n\004song\030\003 \001(\0132\005.So"
  "ngH\000\022\033\n\007concert\030\004 \001(\0132\010.ConcertH\000\022\035\n\010mus"
  "ician\030\005 \001(\0132\t.MusicianH\000\022!\n\nmembership\030\006"
  " \001(\0132\013.MembershipH\000B\005\n\003msg\"*\n\tStreamAns\022"
  "\014\n\004data\030\001 \001(\014\022\017\n\007isFinal\030\002 \001(\010\"\\\n\nMember"
  "ship\022\017\n\007musName\030\001 \001(\t\022\020\n\010bandName\030\002 \001(\t\022"
  "\025\n\runixEntryDate\030\003 \001(\003\022\024\n\014unixQuitDate\030\004"
  " \001(\003\"k\n\007Concert\022\020\n\010capacity\030\001 \001(\005\022\023\n\013des"
  "cription\030\002 \001(\t\022\024\n\014unixDateTime\030\003 \001(\003\022\020\n\010"
  "location\030\004 \001(\t\022\021\n\tbandNames\030\005 \003(\t\"\323\001\n\004Ba"
  "nd\022\020\n\010bandName\030\001 \001(\t\022\025\n\005genre\030\002 \001(\0162\006.Ge"
  "nre\022\025\n\runixFoundDate\030\003 \001(\003\022\024\n\014unixTermDa"
  "te\030\004 \001(\003\022\023\n\013description\030\005 \001(\t\022\r\n\005objId\030\t"
  " \001(\003\022\022\n\nalbumNames\030\006 \003(\t\022!\n\014participants"
  "\030\007 \003(\0132\013.Membership\022\032\n\010concerts\030\010 \003(\0132\010."
  "Concert\"_\n\004Song\022\020\n\010songName\030\001 \001(\t\022\021\n\tlen"
  "gthSec\030\002 \001(\005\022\021\n\talbumName\030\003 \001(\t\022\020\n\010bandN"
  "ame\030\004 \001(\t\022\r\n\005objId\030\005 \001(\003\"W\n\005Album\022\r\n\005tit"
  "le\030\001 \001(\t\022\027\n\017unixReleaseDate\030\002 \001(\003\022\024\n\005son"
  "gs\030\003 \003(\0132\005.Song\022\020\n\010bandName\030\004 \001(\t\"r\n\010Mus"
  "ician\022\017\n\007musName\030\001 \001(\t\022\027\n\017unixDateOfBirt"
  "h\030\002 \001(\003\022\013\n\003bio\030\003 \001(\t\022\r\n\005objId\030\005 \001(\003\022 \n\013m"
  "emberships\030\004 \003(\0132\013.Membership*V\n\nEntityT"
  "ype\022\010\n\004BAND\020\000\022\t\n\005ALBUM\020\001\022\010\n\004SONG\020\002\022\013\n\007CO"
  "NCERT\020\003\022\014\n\010MUSICIAN\020\004\022\016\n\nMEMBERSHIP\020\005*C\n"
  "\005Genre\022\010\n\004ROCK\020\000\022\017\n\013ALTERNATIVE\020\001\022\t\n\005IND"
  "IE\020\002\022\t\n\005BLUES\020\003\022\t\n\005METAL\020\004B\tZ\007./protob\006p"
  "roto3"
  ;
static ::_pbi::once_flag descriptor_table_messages_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_messages_2eproto = {
    false, false, 1765, descriptor_table_protodef_messages_2eproto,
    "messages.proto",
    &descriptor_table_messages_2eproto_once, nullptr, 0, 14,
    schemas, file_default_instances, TableStruct_messages_2eproto::offsets,
    file_level_metadata_messages_2eproto, file_level_enum_descriptors_messages_2eproto,
    file_level_service_descriptors_messages_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_messages_2eproto_getter() {
  return &descriptor_table_messages_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_messages_2eproto(&descriptor_table_messages_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EntityType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messages_2eproto);
  return file_level_enum_descriptors_messages_2eproto[0];
}
bool EntityType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Genre_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messages_2eproto);
  return file_level_enum_descriptors_messages_2eproto[1];
}
bool Genre_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Request::_Internal {
 public:
  static const ::TableReq& tablereq(const Request* msg);
  static const ::SimpleReq& simplereq(const Request* msg);
  static const ::StreamReq& streamreq(const Request* msg);
};

const ::TableReq&
Request::_Internal::tablereq(const Request* msg) {
  return *msg->_impl_.msg_.tablereq_;
}
const ::SimpleReq&
Request::_Internal::simplereq(const Request* msg) {
  return *msg->_impl_.msg_.simplereq_;
}
const ::StreamReq&
Request::_Internal::streamreq(const Request* msg) {
  return *msg->_impl_.msg_.streamreq_;
}
void Request::set_allocated_tablereq(::TableReq* tablereq) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_msg();
  if (tablereq) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tablereq);
    if (message_arena != submessage_arena) {
      tablereq = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tablereq, submessage_arena);
    }
    set_has_tablereq();
    _impl_.msg_.tablereq_ = tablereq;
  }
  // @@protoc_insertion_point(field_set_allocated:Request.tableReq)
}
void Request::set_allocated_simplereq(::SimpleReq* simplereq) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_msg();
  if (simplereq) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(simplereq);
    if (message_arena != submessage_arena) {
      simplereq = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, simplereq, submessage_arena);
    }
    set_has_simplereq();
    _impl_.msg_.simplereq_ = simplereq;
  }
  // @@protoc_insertion_point(field_set_allocated:Request.simpleReq)
}
void Request::set_allocated_streamreq(::StreamReq* streamreq) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_msg();
  if (streamreq) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(streamreq);
    if (message_arena != submessage_arena) {
      streamreq = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, streamreq, submessage_arena);
    }
    set_has_streamreq();
    _impl_.msg_.streamreq_ = streamreq;
  }
  // @@protoc_insertion_point(field_set_allocated:Request.streamReq)
}
Request::Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Request)
}
Request::Request(const Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.reqid_){}
    , decltype(_impl_.cancel_){}
    , decltype(_impl_.msg_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.reqid_, &from._impl_.reqid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cancel_) -
    reinterpret_cast<char*>(&_impl_.reqid_)) + sizeof(_impl_.cancel_));
  clear_has_msg();
  switch (from.msg_case()) {
    case kTableReq: {
      _this->_internal_mutable_tablereq()->::TableReq::MergeFrom(
          from._internal_tablereq());
      break;
    }
    case kSimpleReq: {
      _this->_internal_mutable_simplereq()->::SimpleReq::MergeFrom(
          from._internal_simplereq());
      break;
    }
    case kStreamReq: {
      _this->_internal_mutable_streamreq()->::StreamReq::MergeFrom(
          from._internal_streamreq());
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:Request)
}

inline void Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.reqid_){uint64_t{0u}}
    , decltype(_impl_.cancel_){false}
    , decltype(_impl_.msg_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_msg();
}

Request::~Request() {
  // @@protoc_insertion_point(destructor:Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_msg()) {
    clear_msg();
  }
}

void Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Request::clear_msg() {
// @@protoc_insertion_point(one_of_clear_start:Request)
  switch (msg_case()) {
    case kTableReq: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.msg_.tablereq_;
      }
      break;
    }
    case kSimpleReq: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.msg_.simplereq_;
      }
      break;
    }
    case kStreamReq: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.msg_.streamreq_;
      }
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MSG_NOT_SET;
}


void Request::Clear() {
// @@protoc_insertion_point(message_clear_start:Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.reqid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.cancel_) -
      reinterpret_cast<char*>(&_impl_.reqid_)) + sizeof(_impl_.cancel_));
  clear_msg();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 reqId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.reqid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool cancel = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.cancel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .TableReq tableReq = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_tablereq(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SimpleReq simpleReq = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_simplereq(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .StreamReq streamReq = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_streamreq(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 reqId = 1;
  if (this->_internal_reqid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_reqid(), target);
  }

  // bool cancel = 3;
  if (this->_internal_cancel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_cancel(), target);
  }

  // .TableReq tableReq = 4;
  if (_internal_has_tablereq()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::tablereq(this),
        _Internal::tablereq(this).GetCachedSize(), target, stream);
  }

  // .SimpleReq simpleReq = 5;
  if (_internal_has_simplereq()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::simplereq(this),
        _Internal::simplereq(this).GetCachedSize(), target, stream);
  }

  // .StreamReq streamReq = 6;
  if (_internal_has_streamreq()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::streamreq(this),
        _Internal::streamreq(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Request)
  return target;
}

size_t Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 reqId = 1;
  if (this->_internal_reqid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_reqid());
  }

  // bool cancel = 3;
  if (this->_internal_cancel() != 0) {
    total_size += 1 + 1;
  }

  switch (msg_case()) {
    // .TableReq tableReq = 4;
    case kTableReq: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.msg_.tablereq_);
      break;
    }
    // .SimpleReq simpleReq = 5;
    case kSimpleReq: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.msg_.simplereq_);
      break;
    }
    // .StreamReq streamReq = 6;
    case kStreamReq: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.msg_.streamreq_);
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Request::GetClassData() const { return &_class_data_; }


void Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Request*>(&to_msg);
  auto& from = static_cast<const Request&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_reqid() != 0) {
    _this->_internal_set_reqid(from._internal_reqid());
  }
  if (from._internal_cancel() != 0) {
    _this->_internal_set_cancel(from._internal_cancel());
  }
  switch (from.msg_case()) {
    case kTableReq: {
      _this->_internal_mutable_tablereq()->::TableReq::MergeFrom(
          from._internal_tablereq());
      break;
    }
    case kSimpleReq: {
      _this->_internal_mutable_simplereq()->::SimpleReq::MergeFrom(
          from._internal_simplereq());
      break;
    }
    case kStreamReq: {
      _this->_internal_mutable_streamreq()->::StreamReq::MergeFrom(
          from._internal_streamreq());
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Request::CopyFrom(const Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Request::IsInitialized() const {
  return true;
}

void Request::InternalSwap(Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Request, _impl_.cancel_)
      + sizeof(Request::_impl_.cancel_)
      - PROTOBUF_FIELD_OFFSET(Request, _impl_.reqid_)>(
          reinterpret_cast<char*>(&_impl_.reqid_),
          reinterpret_cast<char*>(&other->_impl_.reqid_));
  swap(_impl_.msg_, other->_impl_.msg_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[0]);
}

// ===================================================================

class Answer::_Internal {
 public:
  static const ::TableAns& tableans(const Answer* msg);
  static const ::SimpleAns& simpleans(const Answer* msg);
  static const ::StreamAns& streamans(const Answer* msg);
};

const ::TableAns&
Answer::_Internal::tableans(const Answer* msg) {
  return *msg->_impl_.msg_.tableans_;
}
const ::SimpleAns&
Answer::_Internal::simpleans(const Answer* msg) {
  return *msg->_impl_.msg_.simpleans_;
}
const ::StreamAns&
Answer::_Internal::streamans(const Answer* msg) {
  return *msg->_impl_.msg_.streamans_;
}
void Answer::set_allocated_tableans(::TableAns* tableans) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_msg();
  if (tableans) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tableans);
    if (message_arena != submessage_arena) {
      tableans = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tableans, submessage_arena);
    }
    set_has_tableans();
    _impl_.msg_.tableans_ = tableans;
  }
  // @@protoc_insertion_point(field_set_allocated:Answer.tableAns)
}
void Answer::set_allocated_simpleans(::SimpleAns* simpleans) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_msg();
  if (simpleans) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(simpleans);
    if (message_arena != submessage_arena) {
      simpleans = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, simpleans, submessage_arena);
    }
    set_has_simpleans();
    _impl_.msg_.simpleans_ = simpleans;
  }
  // @@protoc_insertion_point(field_set_allocated:Answer.simpleAns)
}
void Answer::set_allocated_streamans(::StreamAns* streamans) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_msg();
  if (streamans) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(streamans);
    if (message_arena != submessage_arena) {
      streamans = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, streamans, submessage_arena);
    }
    set_has_streamans();
    _impl_.msg_.streamans_ = streamans;
  }
  // @@protoc_insertion_point(field_set_allocated:Answer.streamAns)
}
Answer::Answer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Answer)
}
Answer::Answer(const Answer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Answer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.reqid_){}
    , decltype(_impl_.cancel_){}
    , decltype(_impl_.msg_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.reqid_, &from._impl_.reqid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cancel_) -
    reinterpret_cast<char*>(&_impl_.reqid_)) + sizeof(_impl_.cancel_));
  clear_has_msg();
  switch (from.msg_case()) {
    case kTableAns: {
      _this->_internal_mutable_tableans()->::TableAns::MergeFrom(
          from._internal_tableans());
      break;
    }
    case kSimpleAns: {
      _this->_internal_mutable_simpleans()->::SimpleAns::MergeFrom(
          from._internal_simpleans());
      break;
    }
    case kStreamAns: {
      _this->_internal_mutable_streamans()->::StreamAns::MergeFrom(
          from._internal_streamans());
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:Answer)
}

inline void Answer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.reqid_){uint64_t{0u}}
    , decltype(_impl_.cancel_){false}
    , decltype(_impl_.msg_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_msg();
}

Answer::~Answer() {
  // @@protoc_insertion_point(destructor:Answer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Answer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_msg()) {
    clear_msg();
  }
}

void Answer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Answer::clear_msg() {
// @@protoc_insertion_point(one_of_clear_start:Answer)
  switch (msg_case()) {
    case kTableAns: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.msg_.tableans_;
      }
      break;
    }
    case kSimpleAns: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.msg_.simpleans_;
      }
      break;
    }
    case kStreamAns: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.msg_.streamans_;
      }
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MSG_NOT_SET;
}


void Answer::Clear() {
// @@protoc_insertion_point(message_clear_start:Answer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.reqid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.cancel_) -
      reinterpret_cast<char*>(&_impl_.reqid_)) + sizeof(_impl_.cancel_));
  clear_msg();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Answer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 reqId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.reqid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool cancel = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.cancel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .TableAns tableAns = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tableans(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SimpleAns simpleAns = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_simpleans(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .StreamAns streamAns = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_streamans(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Answer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Answer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 reqId = 1;
  if (this->_internal_reqid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_reqid(), target);
  }

  // bool cancel = 2;
  if (this->_internal_cancel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_cancel(), target);
  }

  // .TableAns tableAns = 3;
  if (_internal_has_tableans()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::tableans(this),
        _Internal::tableans(this).GetCachedSize(), target, stream);
  }

  // .SimpleAns simpleAns = 4;
  if (_internal_has_simpleans()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::simpleans(this),
        _Internal::simpleans(this).GetCachedSize(), target, stream);
  }

  // .StreamAns streamAns = 5;
  if (_internal_has_streamans()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::streamans(this),
        _Internal::streamans(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Answer)
  return target;
}

size_t Answer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Answer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 reqId = 1;
  if (this->_internal_reqid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_reqid());
  }

  // bool cancel = 2;
  if (this->_internal_cancel() != 0) {
    total_size += 1 + 1;
  }

  switch (msg_case()) {
    // .TableAns tableAns = 3;
    case kTableAns: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.msg_.tableans_);
      break;
    }
    // .SimpleAns simpleAns = 4;
    case kSimpleAns: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.msg_.simpleans_);
      break;
    }
    // .StreamAns streamAns = 5;
    case kStreamAns: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.msg_.streamans_);
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Answer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Answer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Answer::GetClassData() const { return &_class_data_; }


void Answer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Answer*>(&to_msg);
  auto& from = static_cast<const Answer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Answer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_reqid() != 0) {
    _this->_internal_set_reqid(from._internal_reqid());
  }
  if (from._internal_cancel() != 0) {
    _this->_internal_set_cancel(from._internal_cancel());
  }
  switch (from.msg_case()) {
    case kTableAns: {
      _this->_internal_mutable_tableans()->::TableAns::MergeFrom(
          from._internal_tableans());
      break;
    }
    case kSimpleAns: {
      _this->_internal_mutable_simpleans()->::SimpleAns::MergeFrom(
          from._internal_simpleans());
      break;
    }
    case kStreamAns: {
      _this->_internal_mutable_streamans()->::StreamAns::MergeFrom(
          from._internal_streamans());
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Answer::CopyFrom(const Answer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Answer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Answer::IsInitialized() const {
  return true;
}

void Answer::InternalSwap(Answer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Answer, _impl_.cancel_)
      + sizeof(Answer::_impl_.cancel_)
      - PROTOBUF_FIELD_OFFSET(Answer, _impl_.reqid_)>(
          reinterpret_cast<char*>(&_impl_.reqid_),
          reinterpret_cast<char*>(&other->_impl_.reqid_));
  swap(_impl_.msg_, other->_impl_.msg_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Answer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[1]);
}

// ===================================================================

class TableReq::_Internal {
 public:
};

TableReq::TableReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TableReq)
}
TableReq::TableReq(const TableReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TableReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.filter_){}
    , decltype(_impl_.first_){}
    , decltype(_impl_.last_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.filter_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filter_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_filter().empty()) {
    _this->_impl_.filter_.Set(from._internal_filter(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.first_, &from._impl_.first_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.first_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:TableReq)
}

inline void TableReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.filter_){}
    , decltype(_impl_.first_){0u}
    , decltype(_impl_.last_){0u}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.filter_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filter_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TableReq::~TableReq() {
  // @@protoc_insertion_point(destructor:TableReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TableReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.filter_.Destroy();
}

void TableReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TableReq::Clear() {
// @@protoc_insertion_point(message_clear_start:TableReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.filter_.ClearToEmpty();
  ::memset(&_impl_.first_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.type_) -
      reinterpret_cast<char*>(&_impl_.first_)) + sizeof(_impl_.type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 first = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.first_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 last = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.last_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string filter = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_filter();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "TableReq.filter"));
        } else
          goto handle_unusual;
        continue;
      // .EntityType type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::EntityType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TableReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 first = 1;
  if (this->_internal_first() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_first(), target);
  }

  // uint32 last = 2;
  if (this->_internal_last() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_last(), target);
  }

  // string filter = 3;
  if (!this->_internal_filter().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_filter().data(), static_cast<int>(this->_internal_filter().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "TableReq.filter");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_filter(), target);
  }

  // .EntityType type = 4;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TableReq)
  return target;
}

size_t TableReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TableReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string filter = 3;
  if (!this->_internal_filter().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_filter());
  }

  // uint32 first = 1;
  if (this->_internal_first() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_first());
  }

  // uint32 last = 2;
  if (this->_internal_last() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_last());
  }

  // .EntityType type = 4;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TableReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableReq::GetClassData() const { return &_class_data_; }


void TableReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TableReq*>(&to_msg);
  auto& from = static_cast<const TableReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TableReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_filter().empty()) {
    _this->_internal_set_filter(from._internal_filter());
  }
  if (from._internal_first() != 0) {
    _this->_internal_set_first(from._internal_first());
  }
  if (from._internal_last() != 0) {
    _this->_internal_set_last(from._internal_last());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableReq::CopyFrom(const TableReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TableReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableReq::IsInitialized() const {
  return true;
}

void TableReq::InternalSwap(TableReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filter_, lhs_arena,
      &other->_impl_.filter_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TableReq, _impl_.type_)
      + sizeof(TableReq::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(TableReq, _impl_.first_)>(
          reinterpret_cast<char*>(&_impl_.first_),
          reinterpret_cast<char*>(&other->_impl_.first_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TableReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[2]);
}

// ===================================================================

class SimpleReq::_Internal {
 public:
};

SimpleReq::SimpleReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SimpleReq)
}
SimpleReq::SimpleReq(const SimpleReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SimpleReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.reqstring_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.reqstring_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reqstring_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_reqstring().empty()) {
    _this->_impl_.reqstring_.Set(from._internal_reqstring(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:SimpleReq)
}

inline void SimpleReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.reqstring_){}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.reqstring_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reqstring_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SimpleReq::~SimpleReq() {
  // @@protoc_insertion_point(destructor:SimpleReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SimpleReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.reqstring_.Destroy();
}

void SimpleReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SimpleReq::Clear() {
// @@protoc_insertion_point(message_clear_start:SimpleReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.reqstring_.ClearToEmpty();
  _impl_.type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SimpleReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string reqString = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_reqstring();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SimpleReq.reqString"));
        } else
          goto handle_unusual;
        continue;
      // .EntityType type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::EntityType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SimpleReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SimpleReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string reqString = 1;
  if (!this->_internal_reqstring().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_reqstring().data(), static_cast<int>(this->_internal_reqstring().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SimpleReq.reqString");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_reqstring(), target);
  }

  // .EntityType type = 4;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SimpleReq)
  return target;
}

size_t SimpleReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SimpleReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string reqString = 1;
  if (!this->_internal_reqstring().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_reqstring());
  }

  // .EntityType type = 4;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SimpleReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SimpleReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SimpleReq::GetClassData() const { return &_class_data_; }


void SimpleReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SimpleReq*>(&to_msg);
  auto& from = static_cast<const SimpleReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SimpleReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_reqstring().empty()) {
    _this->_internal_set_reqstring(from._internal_reqstring());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SimpleReq::CopyFrom(const SimpleReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SimpleReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimpleReq::IsInitialized() const {
  return true;
}

void SimpleReq::InternalSwap(SimpleReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reqstring_, lhs_arena,
      &other->_impl_.reqstring_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SimpleReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[3]);
}

// ===================================================================

class StreamReq::_Internal {
 public:
};

StreamReq::StreamReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StreamReq)
}
StreamReq::StreamReq(const StreamReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.objid_){}
    , decltype(_impl_.suggestedsize_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.objid_, &from._impl_.objid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.suggestedsize_) -
    reinterpret_cast<char*>(&_impl_.objid_)) + sizeof(_impl_.suggestedsize_));
  // @@protoc_insertion_point(copy_constructor:StreamReq)
}

inline void StreamReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.objid_){int64_t{0}}
    , decltype(_impl_.suggestedsize_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StreamReq::~StreamReq() {
  // @@protoc_insertion_point(destructor:StreamReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StreamReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamReq::Clear() {
// @@protoc_insertion_point(message_clear_start:StreamReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.objid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.suggestedsize_) -
      reinterpret_cast<char*>(&_impl_.objid_)) + sizeof(_impl_.suggestedsize_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 objId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.objid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 suggestedSize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.suggestedsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StreamReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StreamReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 objId = 1;
  if (this->_internal_objid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_objid(), target);
  }

  // int32 suggestedSize = 2;
  if (this->_internal_suggestedsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_suggestedsize(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StreamReq)
  return target;
}

size_t StreamReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StreamReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 objId = 1;
  if (this->_internal_objid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_objid());
  }

  // int32 suggestedSize = 2;
  if (this->_internal_suggestedsize() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_suggestedsize());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamReq::GetClassData() const { return &_class_data_; }


void StreamReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamReq*>(&to_msg);
  auto& from = static_cast<const StreamReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StreamReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_objid() != 0) {
    _this->_internal_set_objid(from._internal_objid());
  }
  if (from._internal_suggestedsize() != 0) {
    _this->_internal_set_suggestedsize(from._internal_suggestedsize());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamReq::CopyFrom(const StreamReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StreamReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamReq::IsInitialized() const {
  return true;
}

void StreamReq::InternalSwap(StreamReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamReq, _impl_.suggestedsize_)
      + sizeof(StreamReq::_impl_.suggestedsize_)
      - PROTOBUF_FIELD_OFFSET(StreamReq, _impl_.objid_)>(
          reinterpret_cast<char*>(&_impl_.objid_),
          reinterpret_cast<char*>(&other->_impl_.objid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[4]);
}

// ===================================================================

class TableAns::_Internal {
 public:
};

TableAns::TableAns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TableAns)
}
TableAns::TableAns(const TableAns& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TableAns* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.bands_){from._impl_.bands_}
    , decltype(_impl_.albums_){from._impl_.albums_}
    , decltype(_impl_.concerts_){from._impl_.concerts_}
    , decltype(_impl_.songs_){from._impl_.songs_}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:TableAns)
}

inline void TableAns::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.bands_){arena}
    , decltype(_impl_.albums_){arena}
    , decltype(_impl_.concerts_){arena}
    , decltype(_impl_.songs_){arena}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TableAns::~TableAns() {
  // @@protoc_insertion_point(destructor:TableAns)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TableAns::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bands_.~RepeatedPtrField();
  _impl_.albums_.~RepeatedPtrField();
  _impl_.concerts_.~RepeatedPtrField();
  _impl_.songs_.~RepeatedPtrField();
}

void TableAns::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TableAns::Clear() {
// @@protoc_insertion_point(message_clear_start:TableAns)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bands_.Clear();
  _impl_.albums_.Clear();
  _impl_.concerts_.Clear();
  _impl_.songs_.Clear();
  _impl_.type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableAns::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .Band bands = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bands(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Album albums = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_albums(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Concert concerts = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_concerts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Song songs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_songs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .EntityType type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::EntityType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableAns::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TableAns)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Band bands = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bands_size()); i < n; i++) {
    const auto& repfield = this->_internal_bands(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .Album albums = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_albums_size()); i < n; i++) {
    const auto& repfield = this->_internal_albums(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .Concert concerts = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_concerts_size()); i < n; i++) {
    const auto& repfield = this->_internal_concerts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .Song songs = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_songs_size()); i < n; i++) {
    const auto& repfield = this->_internal_songs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .EntityType type = 5;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TableAns)
  return target;
}

size_t TableAns::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TableAns)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Band bands = 1;
  total_size += 1UL * this->_internal_bands_size();
  for (const auto& msg : this->_impl_.bands_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Album albums = 2;
  total_size += 1UL * this->_internal_albums_size();
  for (const auto& msg : this->_impl_.albums_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Concert concerts = 3;
  total_size += 1UL * this->_internal_concerts_size();
  for (const auto& msg : this->_impl_.concerts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Song songs = 4;
  total_size += 1UL * this->_internal_songs_size();
  for (const auto& msg : this->_impl_.songs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .EntityType type = 5;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableAns::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TableAns::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableAns::GetClassData() const { return &_class_data_; }


void TableAns::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TableAns*>(&to_msg);
  auto& from = static_cast<const TableAns&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TableAns)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.bands_.MergeFrom(from._impl_.bands_);
  _this->_impl_.albums_.MergeFrom(from._impl_.albums_);
  _this->_impl_.concerts_.MergeFrom(from._impl_.concerts_);
  _this->_impl_.songs_.MergeFrom(from._impl_.songs_);
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableAns::CopyFrom(const TableAns& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TableAns)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableAns::IsInitialized() const {
  return true;
}

void TableAns::InternalSwap(TableAns* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.bands_.InternalSwap(&other->_impl_.bands_);
  _impl_.albums_.InternalSwap(&other->_impl_.albums_);
  _impl_.concerts_.InternalSwap(&other->_impl_.concerts_);
  _impl_.songs_.InternalSwap(&other->_impl_.songs_);
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TableAns::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[5]);
}

// ===================================================================

class SimpleAns::_Internal {
 public:
  static const ::Band& band(const SimpleAns* msg);
  static const ::Album& album(const SimpleAns* msg);
  static const ::Song& song(const SimpleAns* msg);
  static const ::Concert& concert(const SimpleAns* msg);
  static const ::Musician& musician(const SimpleAns* msg);
  static const ::Membership& membership(const SimpleAns* msg);
};

const ::Band&
SimpleAns::_Internal::band(const SimpleAns* msg) {
  return *msg->_impl_.msg_.band_;
}
const ::Album&
SimpleAns::_Internal::album(const SimpleAns* msg) {
  return *msg->_impl_.msg_.album_;
}
const ::Song&
SimpleAns::_Internal::song(const SimpleAns* msg) {
  return *msg->_impl_.msg_.song_;
}
const ::Concert&
SimpleAns::_Internal::concert(const SimpleAns* msg) {
  return *msg->_impl_.msg_.concert_;
}
const ::Musician&
SimpleAns::_Internal::musician(const SimpleAns* msg) {
  return *msg->_impl_.msg_.musician_;
}
const ::Membership&
SimpleAns::_Internal::membership(const SimpleAns* msg) {
  return *msg->_impl_.msg_.membership_;
}
void SimpleAns::set_allocated_band(::Band* band) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_msg();
  if (band) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(band);
    if (message_arena != submessage_arena) {
      band = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, band, submessage_arena);
    }
    set_has_band();
    _impl_.msg_.band_ = band;
  }
  // @@protoc_insertion_point(field_set_allocated:SimpleAns.band)
}
void SimpleAns::set_allocated_album(::Album* album) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_msg();
  if (album) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(album);
    if (message_arena != submessage_arena) {
      album = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, album, submessage_arena);
    }
    set_has_album();
    _impl_.msg_.album_ = album;
  }
  // @@protoc_insertion_point(field_set_allocated:SimpleAns.album)
}
void SimpleAns::set_allocated_song(::Song* song) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_msg();
  if (song) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(song);
    if (message_arena != submessage_arena) {
      song = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, song, submessage_arena);
    }
    set_has_song();
    _impl_.msg_.song_ = song;
  }
  // @@protoc_insertion_point(field_set_allocated:SimpleAns.song)
}
void SimpleAns::set_allocated_concert(::Concert* concert) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_msg();
  if (concert) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(concert);
    if (message_arena != submessage_arena) {
      concert = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, concert, submessage_arena);
    }
    set_has_concert();
    _impl_.msg_.concert_ = concert;
  }
  // @@protoc_insertion_point(field_set_allocated:SimpleAns.concert)
}
void SimpleAns::set_allocated_musician(::Musician* musician) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_msg();
  if (musician) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(musician);
    if (message_arena != submessage_arena) {
      musician = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, musician, submessage_arena);
    }
    set_has_musician();
    _impl_.msg_.musician_ = musician;
  }
  // @@protoc_insertion_point(field_set_allocated:SimpleAns.musician)
}
void SimpleAns::set_allocated_membership(::Membership* membership) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_msg();
  if (membership) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(membership);
    if (message_arena != submessage_arena) {
      membership = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, membership, submessage_arena);
    }
    set_has_membership();
    _impl_.msg_.membership_ = membership;
  }
  // @@protoc_insertion_point(field_set_allocated:SimpleAns.membership)
}
SimpleAns::SimpleAns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SimpleAns)
}
SimpleAns::SimpleAns(const SimpleAns& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SimpleAns* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.msg_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_msg();
  switch (from.msg_case()) {
    case kBand: {
      _this->_internal_mutable_band()->::Band::MergeFrom(
          from._internal_band());
      break;
    }
    case kAlbum: {
      _this->_internal_mutable_album()->::Album::MergeFrom(
          from._internal_album());
      break;
    }
    case kSong: {
      _this->_internal_mutable_song()->::Song::MergeFrom(
          from._internal_song());
      break;
    }
    case kConcert: {
      _this->_internal_mutable_concert()->::Concert::MergeFrom(
          from._internal_concert());
      break;
    }
    case kMusician: {
      _this->_internal_mutable_musician()->::Musician::MergeFrom(
          from._internal_musician());
      break;
    }
    case kMembership: {
      _this->_internal_mutable_membership()->::Membership::MergeFrom(
          from._internal_membership());
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:SimpleAns)
}

inline void SimpleAns::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.msg_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_msg();
}

SimpleAns::~SimpleAns() {
  // @@protoc_insertion_point(destructor:SimpleAns)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SimpleAns::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_msg()) {
    clear_msg();
  }
}

void SimpleAns::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SimpleAns::clear_msg() {
// @@protoc_insertion_point(one_of_clear_start:SimpleAns)
  switch (msg_case()) {
    case kBand: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.msg_.band_;
      }
      break;
    }
    case kAlbum: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.msg_.album_;
      }
      break;
    }
    case kSong: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.msg_.song_;
      }
      break;
    }
    case kConcert: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.msg_.concert_;
      }
      break;
    }
    case kMusician: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.msg_.musician_;
      }
      break;
    }
    case kMembership: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.msg_.membership_;
      }
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MSG_NOT_SET;
}


void SimpleAns::Clear() {
// @@protoc_insertion_point(message_clear_start:SimpleAns)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_msg();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SimpleAns::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Band band = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_band(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Album album = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_album(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Song song = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_song(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Concert concert = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_concert(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Musician musician = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_musician(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Membership membership = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_membership(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SimpleAns::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SimpleAns)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Band band = 1;
  if (_internal_has_band()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::band(this),
        _Internal::band(this).GetCachedSize(), target, stream);
  }

  // .Album album = 2;
  if (_internal_has_album()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::album(this),
        _Internal::album(this).GetCachedSize(), target, stream);
  }

  // .Song song = 3;
  if (_internal_has_song()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::song(this),
        _Internal::song(this).GetCachedSize(), target, stream);
  }

  // .Concert concert = 4;
  if (_internal_has_concert()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::concert(this),
        _Internal::concert(this).GetCachedSize(), target, stream);
  }

  // .Musician musician = 5;
  if (_internal_has_musician()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::musician(this),
        _Internal::musician(this).GetCachedSize(), target, stream);
  }

  // .Membership membership = 6;
  if (_internal_has_membership()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::membership(this),
        _Internal::membership(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SimpleAns)
  return target;
}

size_t SimpleAns::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SimpleAns)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (msg_case()) {
    // .Band band = 1;
    case kBand: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.msg_.band_);
      break;
    }
    // .Album album = 2;
    case kAlbum: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.msg_.album_);
      break;
    }
    // .Song song = 3;
    case kSong: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.msg_.song_);
      break;
    }
    // .Concert concert = 4;
    case kConcert: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.msg_.concert_);
      break;
    }
    // .Musician musician = 5;
    case kMusician: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.msg_.musician_);
      break;
    }
    // .Membership membership = 6;
    case kMembership: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.msg_.membership_);
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SimpleAns::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SimpleAns::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SimpleAns::GetClassData() const { return &_class_data_; }


void SimpleAns::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SimpleAns*>(&to_msg);
  auto& from = static_cast<const SimpleAns&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SimpleAns)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.msg_case()) {
    case kBand: {
      _this->_internal_mutable_band()->::Band::MergeFrom(
          from._internal_band());
      break;
    }
    case kAlbum: {
      _this->_internal_mutable_album()->::Album::MergeFrom(
          from._internal_album());
      break;
    }
    case kSong: {
      _this->_internal_mutable_song()->::Song::MergeFrom(
          from._internal_song());
      break;
    }
    case kConcert: {
      _this->_internal_mutable_concert()->::Concert::MergeFrom(
          from._internal_concert());
      break;
    }
    case kMusician: {
      _this->_internal_mutable_musician()->::Musician::MergeFrom(
          from._internal_musician());
      break;
    }
    case kMembership: {
      _this->_internal_mutable_membership()->::Membership::MergeFrom(
          from._internal_membership());
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SimpleAns::CopyFrom(const SimpleAns& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SimpleAns)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimpleAns::IsInitialized() const {
  return true;
}

void SimpleAns::InternalSwap(SimpleAns* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.msg_, other->_impl_.msg_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SimpleAns::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[6]);
}

// ===================================================================

class StreamAns::_Internal {
 public:
};

StreamAns::StreamAns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StreamAns)
}
StreamAns::StreamAns(const StreamAns& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamAns* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.isfinal_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.isfinal_ = from._impl_.isfinal_;
  // @@protoc_insertion_point(copy_constructor:StreamAns)
}

inline void StreamAns::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.isfinal_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamAns::~StreamAns() {
  // @@protoc_insertion_point(destructor:StreamAns)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamAns::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void StreamAns::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamAns::Clear() {
// @@protoc_insertion_point(message_clear_start:StreamAns)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.ClearToEmpty();
  _impl_.isfinal_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamAns::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isFinal = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.isfinal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StreamAns::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StreamAns)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes data = 1;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_data(), target);
  }

  // bool isFinal = 2;
  if (this->_internal_isfinal() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_isfinal(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StreamAns)
  return target;
}

size_t StreamAns::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StreamAns)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 1;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // bool isFinal = 2;
  if (this->_internal_isfinal() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamAns::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamAns::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamAns::GetClassData() const { return &_class_data_; }


void StreamAns::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamAns*>(&to_msg);
  auto& from = static_cast<const StreamAns&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StreamAns)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  if (from._internal_isfinal() != 0) {
    _this->_internal_set_isfinal(from._internal_isfinal());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamAns::CopyFrom(const StreamAns& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StreamAns)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamAns::IsInitialized() const {
  return true;
}

void StreamAns::InternalSwap(StreamAns* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  swap(_impl_.isfinal_, other->_impl_.isfinal_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamAns::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[7]);
}

// ===================================================================

class Membership::_Internal {
 public:
};

Membership::Membership(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Membership)
}
Membership::Membership(const Membership& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Membership* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.musname_){}
    , decltype(_impl_.bandname_){}
    , decltype(_impl_.unixentrydate_){}
    , decltype(_impl_.unixquitdate_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.musname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.musname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_musname().empty()) {
    _this->_impl_.musname_.Set(from._internal_musname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.bandname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bandname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_bandname().empty()) {
    _this->_impl_.bandname_.Set(from._internal_bandname(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.unixentrydate_, &from._impl_.unixentrydate_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.unixquitdate_) -
    reinterpret_cast<char*>(&_impl_.unixentrydate_)) + sizeof(_impl_.unixquitdate_));
  // @@protoc_insertion_point(copy_constructor:Membership)
}

inline void Membership::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.musname_){}
    , decltype(_impl_.bandname_){}
    , decltype(_impl_.unixentrydate_){int64_t{0}}
    , decltype(_impl_.unixquitdate_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.musname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.musname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bandname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bandname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Membership::~Membership() {
  // @@protoc_insertion_point(destructor:Membership)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Membership::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.musname_.Destroy();
  _impl_.bandname_.Destroy();
}

void Membership::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Membership::Clear() {
// @@protoc_insertion_point(message_clear_start:Membership)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.musname_.ClearToEmpty();
  _impl_.bandname_.ClearToEmpty();
  ::memset(&_impl_.unixentrydate_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.unixquitdate_) -
      reinterpret_cast<char*>(&_impl_.unixentrydate_)) + sizeof(_impl_.unixquitdate_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Membership::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string musName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_musname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Membership.musName"));
        } else
          goto handle_unusual;
        continue;
      // string bandName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_bandname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Membership.bandName"));
        } else
          goto handle_unusual;
        continue;
      // int64 unixEntryDate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.unixentrydate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 unixQuitDate = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.unixquitdate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Membership::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Membership)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string musName = 1;
  if (!this->_internal_musname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_musname().data(), static_cast<int>(this->_internal_musname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Membership.musName");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_musname(), target);
  }

  // string bandName = 2;
  if (!this->_internal_bandname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_bandname().data(), static_cast<int>(this->_internal_bandname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Membership.bandName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_bandname(), target);
  }

  // int64 unixEntryDate = 3;
  if (this->_internal_unixentrydate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_unixentrydate(), target);
  }

  // int64 unixQuitDate = 4;
  if (this->_internal_unixquitdate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_unixquitdate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Membership)
  return target;
}

size_t Membership::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Membership)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string musName = 1;
  if (!this->_internal_musname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_musname());
  }

  // string bandName = 2;
  if (!this->_internal_bandname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_bandname());
  }

  // int64 unixEntryDate = 3;
  if (this->_internal_unixentrydate() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_unixentrydate());
  }

  // int64 unixQuitDate = 4;
  if (this->_internal_unixquitdate() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_unixquitdate());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Membership::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Membership::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Membership::GetClassData() const { return &_class_data_; }


void Membership::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Membership*>(&to_msg);
  auto& from = static_cast<const Membership&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Membership)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_musname().empty()) {
    _this->_internal_set_musname(from._internal_musname());
  }
  if (!from._internal_bandname().empty()) {
    _this->_internal_set_bandname(from._internal_bandname());
  }
  if (from._internal_unixentrydate() != 0) {
    _this->_internal_set_unixentrydate(from._internal_unixentrydate());
  }
  if (from._internal_unixquitdate() != 0) {
    _this->_internal_set_unixquitdate(from._internal_unixquitdate());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Membership::CopyFrom(const Membership& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Membership)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Membership::IsInitialized() const {
  return true;
}

void Membership::InternalSwap(Membership* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.musname_, lhs_arena,
      &other->_impl_.musname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bandname_, lhs_arena,
      &other->_impl_.bandname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Membership, _impl_.unixquitdate_)
      + sizeof(Membership::_impl_.unixquitdate_)
      - PROTOBUF_FIELD_OFFSET(Membership, _impl_.unixentrydate_)>(
          reinterpret_cast<char*>(&_impl_.unixentrydate_),
          reinterpret_cast<char*>(&other->_impl_.unixentrydate_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Membership::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[8]);
}

// ===================================================================

class Concert::_Internal {
 public:
};

Concert::Concert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Concert)
}
Concert::Concert(const Concert& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Concert* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.bandnames_){from._impl_.bandnames_}
    , decltype(_impl_.description_){}
    , decltype(_impl_.location_){}
    , decltype(_impl_.unixdatetime_){}
    , decltype(_impl_.capacity_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_location().empty()) {
    _this->_impl_.location_.Set(from._internal_location(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.unixdatetime_, &from._impl_.unixdatetime_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.capacity_) -
    reinterpret_cast<char*>(&_impl_.unixdatetime_)) + sizeof(_impl_.capacity_));
  // @@protoc_insertion_point(copy_constructor:Concert)
}

inline void Concert::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.bandnames_){arena}
    , decltype(_impl_.description_){}
    , decltype(_impl_.location_){}
    , decltype(_impl_.unixdatetime_){int64_t{0}}
    , decltype(_impl_.capacity_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Concert::~Concert() {
  // @@protoc_insertion_point(destructor:Concert)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Concert::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bandnames_.~RepeatedPtrField();
  _impl_.description_.Destroy();
  _impl_.location_.Destroy();
}

void Concert::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Concert::Clear() {
// @@protoc_insertion_point(message_clear_start:Concert)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bandnames_.Clear();
  _impl_.description_.ClearToEmpty();
  _impl_.location_.ClearToEmpty();
  ::memset(&_impl_.unixdatetime_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.capacity_) -
      reinterpret_cast<char*>(&_impl_.unixdatetime_)) + sizeof(_impl_.capacity_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Concert::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 capacity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Concert.description"));
        } else
          goto handle_unusual;
        continue;
      // int64 unixDateTime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.unixdatetime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string location = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_location();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Concert.location"));
        } else
          goto handle_unusual;
        continue;
      // repeated string bandNames = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_bandnames();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "Concert.bandNames"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Concert::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Concert)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 capacity = 1;
  if (this->_internal_capacity() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_capacity(), target);
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Concert.description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  // int64 unixDateTime = 3;
  if (this->_internal_unixdatetime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_unixdatetime(), target);
  }

  // string location = 4;
  if (!this->_internal_location().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_location().data(), static_cast<int>(this->_internal_location().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Concert.location");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_location(), target);
  }

  // repeated string bandNames = 5;
  for (int i = 0, n = this->_internal_bandnames_size(); i < n; i++) {
    const auto& s = this->_internal_bandnames(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Concert.bandNames");
    target = stream->WriteString(5, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Concert)
  return target;
}

size_t Concert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Concert)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string bandNames = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.bandnames_.size());
  for (int i = 0, n = _impl_.bandnames_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.bandnames_.Get(i));
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string location = 4;
  if (!this->_internal_location().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_location());
  }

  // int64 unixDateTime = 3;
  if (this->_internal_unixdatetime() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_unixdatetime());
  }

  // int32 capacity = 1;
  if (this->_internal_capacity() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_capacity());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Concert::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Concert::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Concert::GetClassData() const { return &_class_data_; }


void Concert::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Concert*>(&to_msg);
  auto& from = static_cast<const Concert&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Concert)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.bandnames_.MergeFrom(from._impl_.bandnames_);
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_location().empty()) {
    _this->_internal_set_location(from._internal_location());
  }
  if (from._internal_unixdatetime() != 0) {
    _this->_internal_set_unixdatetime(from._internal_unixdatetime());
  }
  if (from._internal_capacity() != 0) {
    _this->_internal_set_capacity(from._internal_capacity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Concert::CopyFrom(const Concert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Concert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Concert::IsInitialized() const {
  return true;
}

void Concert::InternalSwap(Concert* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.bandnames_.InternalSwap(&other->_impl_.bandnames_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.location_, lhs_arena,
      &other->_impl_.location_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Concert, _impl_.capacity_)
      + sizeof(Concert::_impl_.capacity_)
      - PROTOBUF_FIELD_OFFSET(Concert, _impl_.unixdatetime_)>(
          reinterpret_cast<char*>(&_impl_.unixdatetime_),
          reinterpret_cast<char*>(&other->_impl_.unixdatetime_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Concert::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[9]);
}

// ===================================================================

class Band::_Internal {
 public:
};

Band::Band(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Band)
}
Band::Band(const Band& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Band* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.albumnames_){from._impl_.albumnames_}
    , decltype(_impl_.participants_){from._impl_.participants_}
    , decltype(_impl_.concerts_){from._impl_.concerts_}
    , decltype(_impl_.bandname_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.unixfounddate_){}
    , decltype(_impl_.unixtermdate_){}
    , decltype(_impl_.objid_){}
    , decltype(_impl_.genre_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.bandname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bandname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_bandname().empty()) {
    _this->_impl_.bandname_.Set(from._internal_bandname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.unixfounddate_, &from._impl_.unixfounddate_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.genre_) -
    reinterpret_cast<char*>(&_impl_.unixfounddate_)) + sizeof(_impl_.genre_));
  // @@protoc_insertion_point(copy_constructor:Band)
}

inline void Band::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.albumnames_){arena}
    , decltype(_impl_.participants_){arena}
    , decltype(_impl_.concerts_){arena}
    , decltype(_impl_.bandname_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.unixfounddate_){int64_t{0}}
    , decltype(_impl_.unixtermdate_){int64_t{0}}
    , decltype(_impl_.objid_){int64_t{0}}
    , decltype(_impl_.genre_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.bandname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bandname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Band::~Band() {
  // @@protoc_insertion_point(destructor:Band)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Band::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.albumnames_.~RepeatedPtrField();
  _impl_.participants_.~RepeatedPtrField();
  _impl_.concerts_.~RepeatedPtrField();
  _impl_.bandname_.Destroy();
  _impl_.description_.Destroy();
}

void Band::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Band::Clear() {
// @@protoc_insertion_point(message_clear_start:Band)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.albumnames_.Clear();
  _impl_.participants_.Clear();
  _impl_.concerts_.Clear();
  _impl_.bandname_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  ::memset(&_impl_.unixfounddate_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.genre_) -
      reinterpret_cast<char*>(&_impl_.unixfounddate_)) + sizeof(_impl_.genre_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Band::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string bandName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_bandname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Band.bandName"));
        } else
          goto handle_unusual;
        continue;
      // .Genre genre = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_genre(static_cast<::Genre>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 unixFoundDate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.unixfounddate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 unixTermDate = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.unixtermdate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string description = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Band.description"));
        } else
          goto handle_unusual;
        continue;
      // repeated string albumNames = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_albumnames();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "Band.albumNames"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Membership participants = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_participants(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Concert concerts = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_concerts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int64 objId = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.objid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Band::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Band)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string bandName = 1;
  if (!this->_internal_bandname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_bandname().data(), static_cast<int>(this->_internal_bandname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Band.bandName");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_bandname(), target);
  }

  // .Genre genre = 2;
  if (this->_internal_genre() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_genre(), target);
  }

  // int64 unixFoundDate = 3;
  if (this->_internal_unixfounddate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_unixfounddate(), target);
  }

  // int64 unixTermDate = 4;
  if (this->_internal_unixtermdate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_unixtermdate(), target);
  }

  // string description = 5;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Band.description");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_description(), target);
  }

  // repeated string albumNames = 6;
  for (int i = 0, n = this->_internal_albumnames_size(); i < n; i++) {
    const auto& s = this->_internal_albumnames(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Band.albumNames");
    target = stream->WriteString(6, s, target);
  }

  // repeated .Membership participants = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_participants_size()); i < n; i++) {
    const auto& repfield = this->_internal_participants(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .Concert concerts = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_concerts_size()); i < n; i++) {
    const auto& repfield = this->_internal_concerts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int64 objId = 9;
  if (this->_internal_objid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(9, this->_internal_objid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Band)
  return target;
}

size_t Band::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Band)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string albumNames = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.albumnames_.size());
  for (int i = 0, n = _impl_.albumnames_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.albumnames_.Get(i));
  }

  // repeated .Membership participants = 7;
  total_size += 1UL * this->_internal_participants_size();
  for (const auto& msg : this->_impl_.participants_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Concert concerts = 8;
  total_size += 1UL * this->_internal_concerts_size();
  for (const auto& msg : this->_impl_.concerts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string bandName = 1;
  if (!this->_internal_bandname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_bandname());
  }

  // string description = 5;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // int64 unixFoundDate = 3;
  if (this->_internal_unixfounddate() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_unixfounddate());
  }

  // int64 unixTermDate = 4;
  if (this->_internal_unixtermdate() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_unixtermdate());
  }

  // int64 objId = 9;
  if (this->_internal_objid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_objid());
  }

  // .Genre genre = 2;
  if (this->_internal_genre() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_genre());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Band::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Band::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Band::GetClassData() const { return &_class_data_; }


void Band::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Band*>(&to_msg);
  auto& from = static_cast<const Band&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Band)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.albumnames_.MergeFrom(from._impl_.albumnames_);
  _this->_impl_.participants_.MergeFrom(from._impl_.participants_);
  _this->_impl_.concerts_.MergeFrom(from._impl_.concerts_);
  if (!from._internal_bandname().empty()) {
    _this->_internal_set_bandname(from._internal_bandname());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (from._internal_unixfounddate() != 0) {
    _this->_internal_set_unixfounddate(from._internal_unixfounddate());
  }
  if (from._internal_unixtermdate() != 0) {
    _this->_internal_set_unixtermdate(from._internal_unixtermdate());
  }
  if (from._internal_objid() != 0) {
    _this->_internal_set_objid(from._internal_objid());
  }
  if (from._internal_genre() != 0) {
    _this->_internal_set_genre(from._internal_genre());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Band::CopyFrom(const Band& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Band)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Band::IsInitialized() const {
  return true;
}

void Band::InternalSwap(Band* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.albumnames_.InternalSwap(&other->_impl_.albumnames_);
  _impl_.participants_.InternalSwap(&other->_impl_.participants_);
  _impl_.concerts_.InternalSwap(&other->_impl_.concerts_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bandname_, lhs_arena,
      &other->_impl_.bandname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Band, _impl_.genre_)
      + sizeof(Band::_impl_.genre_)
      - PROTOBUF_FIELD_OFFSET(Band, _impl_.unixfounddate_)>(
          reinterpret_cast<char*>(&_impl_.unixfounddate_),
          reinterpret_cast<char*>(&other->_impl_.unixfounddate_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Band::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[10]);
}

// ===================================================================

class Song::_Internal {
 public:
};

Song::Song(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Song)
}
Song::Song(const Song& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Song* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.songname_){}
    , decltype(_impl_.albumname_){}
    , decltype(_impl_.bandname_){}
    , decltype(_impl_.objid_){}
    , decltype(_impl_.lengthsec_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.songname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.songname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_songname().empty()) {
    _this->_impl_.songname_.Set(from._internal_songname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.albumname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.albumname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_albumname().empty()) {
    _this->_impl_.albumname_.Set(from._internal_albumname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.bandname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bandname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_bandname().empty()) {
    _this->_impl_.bandname_.Set(from._internal_bandname(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.objid_, &from._impl_.objid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.lengthsec_) -
    reinterpret_cast<char*>(&_impl_.objid_)) + sizeof(_impl_.lengthsec_));
  // @@protoc_insertion_point(copy_constructor:Song)
}

inline void Song::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.songname_){}
    , decltype(_impl_.albumname_){}
    , decltype(_impl_.bandname_){}
    , decltype(_impl_.objid_){int64_t{0}}
    , decltype(_impl_.lengthsec_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.songname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.songname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.albumname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.albumname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bandname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bandname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Song::~Song() {
  // @@protoc_insertion_point(destructor:Song)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Song::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.songname_.Destroy();
  _impl_.albumname_.Destroy();
  _impl_.bandname_.Destroy();
}

void Song::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Song::Clear() {
// @@protoc_insertion_point(message_clear_start:Song)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.songname_.ClearToEmpty();
  _impl_.albumname_.ClearToEmpty();
  _impl_.bandname_.ClearToEmpty();
  ::memset(&_impl_.objid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.lengthsec_) -
      reinterpret_cast<char*>(&_impl_.objid_)) + sizeof(_impl_.lengthsec_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Song::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string songName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_songname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Song.songName"));
        } else
          goto handle_unusual;
        continue;
      // int32 lengthSec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.lengthsec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string albumName = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_albumname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Song.albumName"));
        } else
          goto handle_unusual;
        continue;
      // string bandName = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_bandname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Song.bandName"));
        } else
          goto handle_unusual;
        continue;
      // int64 objId = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.objid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Song::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Song)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string songName = 1;
  if (!this->_internal_songname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_songname().data(), static_cast<int>(this->_internal_songname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Song.songName");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_songname(), target);
  }

  // int32 lengthSec = 2;
  if (this->_internal_lengthsec() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_lengthsec(), target);
  }

  // string albumName = 3;
  if (!this->_internal_albumname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_albumname().data(), static_cast<int>(this->_internal_albumname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Song.albumName");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_albumname(), target);
  }

  // string bandName = 4;
  if (!this->_internal_bandname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_bandname().data(), static_cast<int>(this->_internal_bandname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Song.bandName");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_bandname(), target);
  }

  // int64 objId = 5;
  if (this->_internal_objid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_objid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Song)
  return target;
}

size_t Song::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Song)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string songName = 1;
  if (!this->_internal_songname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_songname());
  }

  // string albumName = 3;
  if (!this->_internal_albumname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_albumname());
  }

  // string bandName = 4;
  if (!this->_internal_bandname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_bandname());
  }

  // int64 objId = 5;
  if (this->_internal_objid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_objid());
  }

  // int32 lengthSec = 2;
  if (this->_internal_lengthsec() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_lengthsec());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Song::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Song::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Song::GetClassData() const { return &_class_data_; }


void Song::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Song*>(&to_msg);
  auto& from = static_cast<const Song&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Song)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_songname().empty()) {
    _this->_internal_set_songname(from._internal_songname());
  }
  if (!from._internal_albumname().empty()) {
    _this->_internal_set_albumname(from._internal_albumname());
  }
  if (!from._internal_bandname().empty()) {
    _this->_internal_set_bandname(from._internal_bandname());
  }
  if (from._internal_objid() != 0) {
    _this->_internal_set_objid(from._internal_objid());
  }
  if (from._internal_lengthsec() != 0) {
    _this->_internal_set_lengthsec(from._internal_lengthsec());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Song::CopyFrom(const Song& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Song)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Song::IsInitialized() const {
  return true;
}

void Song::InternalSwap(Song* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.songname_, lhs_arena,
      &other->_impl_.songname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.albumname_, lhs_arena,
      &other->_impl_.albumname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bandname_, lhs_arena,
      &other->_impl_.bandname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Song, _impl_.lengthsec_)
      + sizeof(Song::_impl_.lengthsec_)
      - PROTOBUF_FIELD_OFFSET(Song, _impl_.objid_)>(
          reinterpret_cast<char*>(&_impl_.objid_),
          reinterpret_cast<char*>(&other->_impl_.objid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Song::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[11]);
}

// ===================================================================

class Album::_Internal {
 public:
};

Album::Album(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Album)
}
Album::Album(const Album& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Album* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.songs_){from._impl_.songs_}
    , decltype(_impl_.title_){}
    , decltype(_impl_.bandname_){}
    , decltype(_impl_.unixreleasedate_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_title().empty()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.bandname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bandname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_bandname().empty()) {
    _this->_impl_.bandname_.Set(from._internal_bandname(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.unixreleasedate_ = from._impl_.unixreleasedate_;
  // @@protoc_insertion_point(copy_constructor:Album)
}

inline void Album::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.songs_){arena}
    , decltype(_impl_.title_){}
    , decltype(_impl_.bandname_){}
    , decltype(_impl_.unixreleasedate_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bandname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bandname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Album::~Album() {
  // @@protoc_insertion_point(destructor:Album)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Album::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.songs_.~RepeatedPtrField();
  _impl_.title_.Destroy();
  _impl_.bandname_.Destroy();
}

void Album::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Album::Clear() {
// @@protoc_insertion_point(message_clear_start:Album)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.songs_.Clear();
  _impl_.title_.ClearToEmpty();
  _impl_.bandname_.ClearToEmpty();
  _impl_.unixreleasedate_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Album::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string title = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Album.title"));
        } else
          goto handle_unusual;
        continue;
      // int64 unixReleaseDate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.unixreleasedate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Song songs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_songs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string bandName = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_bandname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Album.bandName"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Album::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Album)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string title = 1;
  if (!this->_internal_title().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Album.title");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_title(), target);
  }

  // int64 unixReleaseDate = 2;
  if (this->_internal_unixreleasedate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_unixreleasedate(), target);
  }

  // repeated .Song songs = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_songs_size()); i < n; i++) {
    const auto& repfield = this->_internal_songs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string bandName = 4;
  if (!this->_internal_bandname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_bandname().data(), static_cast<int>(this->_internal_bandname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Album.bandName");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_bandname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Album)
  return target;
}

size_t Album::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Album)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Song songs = 3;
  total_size += 1UL * this->_internal_songs_size();
  for (const auto& msg : this->_impl_.songs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string title = 1;
  if (!this->_internal_title().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_title());
  }

  // string bandName = 4;
  if (!this->_internal_bandname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_bandname());
  }

  // int64 unixReleaseDate = 2;
  if (this->_internal_unixreleasedate() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_unixreleasedate());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Album::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Album::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Album::GetClassData() const { return &_class_data_; }


void Album::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Album*>(&to_msg);
  auto& from = static_cast<const Album&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Album)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.songs_.MergeFrom(from._impl_.songs_);
  if (!from._internal_title().empty()) {
    _this->_internal_set_title(from._internal_title());
  }
  if (!from._internal_bandname().empty()) {
    _this->_internal_set_bandname(from._internal_bandname());
  }
  if (from._internal_unixreleasedate() != 0) {
    _this->_internal_set_unixreleasedate(from._internal_unixreleasedate());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Album::CopyFrom(const Album& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Album)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Album::IsInitialized() const {
  return true;
}

void Album::InternalSwap(Album* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.songs_.InternalSwap(&other->_impl_.songs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bandname_, lhs_arena,
      &other->_impl_.bandname_, rhs_arena
  );
  swap(_impl_.unixreleasedate_, other->_impl_.unixreleasedate_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Album::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[12]);
}

// ===================================================================

class Musician::_Internal {
 public:
};

Musician::Musician(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Musician)
}
Musician::Musician(const Musician& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Musician* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.memberships_){from._impl_.memberships_}
    , decltype(_impl_.musname_){}
    , decltype(_impl_.bio_){}
    , decltype(_impl_.unixdateofbirth_){}
    , decltype(_impl_.objid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.musname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.musname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_musname().empty()) {
    _this->_impl_.musname_.Set(from._internal_musname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.bio_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bio_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_bio().empty()) {
    _this->_impl_.bio_.Set(from._internal_bio(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.unixdateofbirth_, &from._impl_.unixdateofbirth_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.objid_) -
    reinterpret_cast<char*>(&_impl_.unixdateofbirth_)) + sizeof(_impl_.objid_));
  // @@protoc_insertion_point(copy_constructor:Musician)
}

inline void Musician::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.memberships_){arena}
    , decltype(_impl_.musname_){}
    , decltype(_impl_.bio_){}
    , decltype(_impl_.unixdateofbirth_){int64_t{0}}
    , decltype(_impl_.objid_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.musname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.musname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bio_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bio_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Musician::~Musician() {
  // @@protoc_insertion_point(destructor:Musician)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Musician::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.memberships_.~RepeatedPtrField();
  _impl_.musname_.Destroy();
  _impl_.bio_.Destroy();
}

void Musician::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Musician::Clear() {
// @@protoc_insertion_point(message_clear_start:Musician)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.memberships_.Clear();
  _impl_.musname_.ClearToEmpty();
  _impl_.bio_.ClearToEmpty();
  ::memset(&_impl_.unixdateofbirth_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.objid_) -
      reinterpret_cast<char*>(&_impl_.unixdateofbirth_)) + sizeof(_impl_.objid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Musician::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string musName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_musname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Musician.musName"));
        } else
          goto handle_unusual;
        continue;
      // int64 unixDateOfBirth = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.unixdateofbirth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string bio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_bio();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Musician.bio"));
        } else
          goto handle_unusual;
        continue;
      // repeated .Membership memberships = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_memberships(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int64 objId = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.objid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Musician::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Musician)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string musName = 1;
  if (!this->_internal_musname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_musname().data(), static_cast<int>(this->_internal_musname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Musician.musName");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_musname(), target);
  }

  // int64 unixDateOfBirth = 2;
  if (this->_internal_unixdateofbirth() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_unixdateofbirth(), target);
  }

  // string bio = 3;
  if (!this->_internal_bio().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_bio().data(), static_cast<int>(this->_internal_bio().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Musician.bio");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_bio(), target);
  }

  // repeated .Membership memberships = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_memberships_size()); i < n; i++) {
    const auto& repfield = this->_internal_memberships(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int64 objId = 5;
  if (this->_internal_objid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_objid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Musician)
  return target;
}

size_t Musician::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Musician)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Membership memberships = 4;
  total_size += 1UL * this->_internal_memberships_size();
  for (const auto& msg : this->_impl_.memberships_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string musName = 1;
  if (!this->_internal_musname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_musname());
  }

  // string bio = 3;
  if (!this->_internal_bio().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_bio());
  }

  // int64 unixDateOfBirth = 2;
  if (this->_internal_unixdateofbirth() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_unixdateofbirth());
  }

  // int64 objId = 5;
  if (this->_internal_objid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_objid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Musician::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Musician::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Musician::GetClassData() const { return &_class_data_; }


void Musician::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Musician*>(&to_msg);
  auto& from = static_cast<const Musician&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Musician)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.memberships_.MergeFrom(from._impl_.memberships_);
  if (!from._internal_musname().empty()) {
    _this->_internal_set_musname(from._internal_musname());
  }
  if (!from._internal_bio().empty()) {
    _this->_internal_set_bio(from._internal_bio());
  }
  if (from._internal_unixdateofbirth() != 0) {
    _this->_internal_set_unixdateofbirth(from._internal_unixdateofbirth());
  }
  if (from._internal_objid() != 0) {
    _this->_internal_set_objid(from._internal_objid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Musician::CopyFrom(const Musician& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Musician)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Musician::IsInitialized() const {
  return true;
}

void Musician::InternalSwap(Musician* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.memberships_.InternalSwap(&other->_impl_.memberships_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.musname_, lhs_arena,
      &other->_impl_.musname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bio_, lhs_arena,
      &other->_impl_.bio_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Musician, _impl_.objid_)
      + sizeof(Musician::_impl_.objid_)
      - PROTOBUF_FIELD_OFFSET(Musician, _impl_.unixdateofbirth_)>(
          reinterpret_cast<char*>(&_impl_.unixdateofbirth_),
          reinterpret_cast<char*>(&other->_impl_.unixdateofbirth_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Musician::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[13]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Request*
Arena::CreateMaybeMessage< ::Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Request >(arena);
}
template<> PROTOBUF_NOINLINE ::Answer*
Arena::CreateMaybeMessage< ::Answer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Answer >(arena);
}
template<> PROTOBUF_NOINLINE ::TableReq*
Arena::CreateMaybeMessage< ::TableReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TableReq >(arena);
}
template<> PROTOBUF_NOINLINE ::SimpleReq*
Arena::CreateMaybeMessage< ::SimpleReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SimpleReq >(arena);
}
template<> PROTOBUF_NOINLINE ::StreamReq*
Arena::CreateMaybeMessage< ::StreamReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StreamReq >(arena);
}
template<> PROTOBUF_NOINLINE ::TableAns*
Arena::CreateMaybeMessage< ::TableAns >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TableAns >(arena);
}
template<> PROTOBUF_NOINLINE ::SimpleAns*
Arena::CreateMaybeMessage< ::SimpleAns >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SimpleAns >(arena);
}
template<> PROTOBUF_NOINLINE ::StreamAns*
Arena::CreateMaybeMessage< ::StreamAns >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StreamAns >(arena);
}
template<> PROTOBUF_NOINLINE ::Membership*
Arena::CreateMaybeMessage< ::Membership >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Membership >(arena);
}
template<> PROTOBUF_NOINLINE ::Concert*
Arena::CreateMaybeMessage< ::Concert >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Concert >(arena);
}
template<> PROTOBUF_NOINLINE ::Band*
Arena::CreateMaybeMessage< ::Band >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Band >(arena);
}
template<> PROTOBUF_NOINLINE ::Song*
Arena::CreateMaybeMessage< ::Song >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Song >(arena);
}
template<> PROTOBUF_NOINLINE ::Album*
Arena::CreateMaybeMessage< ::Album >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Album >(arena);
}
template<> PROTOBUF_NOINLINE ::Musician*
Arena::CreateMaybeMessage< ::Musician >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Musician >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
